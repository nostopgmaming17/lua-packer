local f={}do local E=function()local h={new=function(H,i)local I={Parent=i,Locals={},Globals={},oldLocalNamesMap={},oldGlobalNamesMap={},Children={}}if i then table.insert(i.Children,I)end;return setmetatable(I,{__index=H})end,AddLocal=function(H,i)table.insert(H.Locals,i)end,AddGlobal=function(H,i)table.insert(H.Globals,i)end,CreateLocal=function(H,i)local I;I=H:GetLocal(i)if I then return I end;I={}I.Scope=H;I.Name=i;I.IsGlobal=false;I.CanRename=true;I.References=1;H:AddLocal(I)return I end,GetLocal=function(H,i)for I,j in pairs(H.Locals)do if j.Name==i then return j end end;if H.Parent then return H.Parent:GetLocal(i)end end,GetOldLocal=function(H,i)if H.oldLocalNamesMap[i]then return H.oldLocalNamesMap[i]end;return H:GetLocal(i)end,mapLocal=function(H,i,I)H.oldLocalNamesMap[i]=I end,GetOldGlobal=function(H,i)if H.oldGlobalNamesMap[i]then return H.oldGlobalNamesMap[i]end;return H:GetGlobal(i)end,mapGlobal=function(H,i,I)H.oldGlobalNamesMap[i]=I end,GetOldVariable=function(H,i)return H:GetOldLocal(i)or H:GetOldGlobal(i)end,RenameLocal=function(H,i,I)i=type(i)=='string'and i or i.Name;local j=false;local J=H:GetLocal(i)if J then J.Name=I;H:mapLocal(i,J)j=true end;if not j and H.Parent then H.Parent:RenameLocal(i,I)end end,RenameGlobal=function(H,i,I)i=type(i)=='string'and i or i.Name;local j=false;local J=H:GetGlobal(i)if J then J.Name=I;H:mapGlobal(i,J)j=true end;if not j and H.Parent then H.Parent:RenameGlobal(i,I)end end,RenameVariable=function(H,i,I)i=type(i)=='string'and i or i.Name;if H:GetLocal(i)then H:RenameLocal(i,I)else H:RenameGlobal(i,I)end end,GetAllVariables=function(H)local i=H:getVars(true)for I,j in pairs(H:getVars(false))do table.insert(i,j)end;return i end,getVars=function(H,i)local I={}if i then for j,J in pairs(H.Children)do for k,K in pairs(J:getVars(true))do table.insert(I,K)end end else for j,J in pairs(H.Locals)do table.insert(I,J)end;for j,J in pairs(H.Globals)do table.insert(I,J)end;if H.Parent then for j,J in pairs(H.Parent:getVars(false))do table.insert(I,J)end end end;return I end,CreateGlobal=function(H,i)local I;I=H:GetGlobal(i)if I then return I end;I={}I.Scope=H;I.Name=i;I.IsGlobal=true;I.CanRename=true;I.References=1;H:AddGlobal(I)return I end,GetGlobal=function(H,i)for I,j in pairs(H.Globals)do if j.Name==i then return j end end;if H.Parent then return H.Parent:GetGlobal(i)end end,GetVariable=function(H,i)return H:GetLocal(i)or H:GetGlobal(i)end,ObfuscateLocals=function(H,i,I)i=i or 7;local j="aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ_"local J="0123456789"local k=j..J;for K,l in pairs(H.Locals)do local L="a"local m={1}local M=0;while H:GetVariable(L)do local n=#m>1 and#k or#j;m[#m]=m[#m]+1;for N=1,#m-1 do if m[N+1]>n then m[N]=m[N]+1;m[N+1]=1 end end;if m[1]>n then m[1]=1;table.insert(m,1)end;L=""for N=1,#m do L=L..k:sub(m[N],m[N])end end;H:RenameLocal(l.Name,L)end end}return h end;f[5]=function()local h=E()f[5]=function()return h end;return h end end;do local E=function()local h=f[1]()local H=h.ParseLua;local i=f[3]()local I=i.lookupify;local j=I{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local J=I{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local k=I{'0','1','2','3','4','5','6','7','8','9'}local K=I{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local function l(L)local m,M;local n=0;local function N(O,p,P)P=P or' 'local q,Q=O:sub(-1,-1),p:sub(1,1)if J[q]or j[q]or q=='_'then if not(J[Q]or j[Q]or Q=='_'or k[Q])then return O..p elseif Q=='('then print("==============>>>",q,Q)return O..P..p else return O..P..p end elseif k[q]then if Q=='('then return O..p elseif K[Q]then return O..p else return O..P..p end elseif q==''then return O..p else if Q=='('then return O..P..p else return O..p end end end;M=function(O,p)local p=p or 0;local P=0;local q=false;local Q=""if O.AstType=='VarExpr'then if O.Variable then Q=Q..O.Variable.Name else Q=Q..O.Name end elseif O.AstType=='NumberExpr'then Q=Q..O.Value.Data elseif O.AstType=='StringExpr'then Q=Q..O.Value.Data elseif O.AstType=='BooleanExpr'then Q=Q..tostring(O.Value)elseif O.AstType=='NilExpr'then Q=N(Q,"nil")elseif O.AstType=='BinopExpr'then P=O.OperatorPrecedence;Q=N(Q,M(O.Lhs,P))Q=N(Q,O.Op)Q=N(Q,M(O.Rhs))if O.Op=='^'or O.Op=='..'then P=P-1 end;if P<p then q=false else q=true end elseif O.AstType=='UnopExpr'then Q=N(Q,O.Op)Q=N(Q,M(O.Rhs))elseif O.AstType=='DotsExpr'then Q=Q.."..."elseif O.AstType=='CallExpr'then Q=Q..M(O.Base)Q=Q.."("for r=1,#O.Arguments do Q=Q..M(O.Arguments[r])if r~=#O.Arguments then Q=Q..","end end;Q=Q..")"elseif O.AstType=='TableCallExpr'then Q=Q..M(O.Base)Q=Q..M(O.Arguments[1])elseif O.AstType=='StringCallExpr'then Q=Q..M(O.Base)Q=Q..O.Arguments[1].Data elseif O.AstType=='IndexExpr'then Q=Q..M(O.Base).."["..M(O.Index).."]"elseif O.AstType=='MemberExpr'then Q=Q..M(O.Base)..O.Indexer..O.Ident.Data elseif O.AstType=='Function'then O.Scope:ObfuscateVariables()Q=Q.."function("if#O.Arguments>0 then for r=1,#O.Arguments do Q=Q..O.Arguments[r].Name;if r~=#O.Arguments then Q=Q..","elseif O.VarArg then Q=Q..",..."end end elseif O.VarArg then Q=Q.."..."end;Q=Q..")"Q=N(Q,m(O.Body))Q=N(Q,"end")elseif O.AstType=='ConstructorExpr'then Q=Q.."{"for r=1,#O.EntryList do local R=O.EntryList[r]if R.Type=='Key'then Q=Q.."["..M(R.Key).."]="..M(R.Value)elseif R.Type=='Value'then Q=Q..M(R.Value)elseif R.Type=='KeyString'then Q=Q..R.Key.."="..M(R.Value)end;if r~=#O.EntryList then Q=Q..","end end;Q=Q.."}"elseif O.AstType=='Parentheses'then Q=Q.."("..M(O.Inner)..")"end;if not q then Q=string.rep('(',O.ParenCount or 0)..Q;Q=Q..string.rep(')',O.ParenCount or 0)end;n=n+#Q;return Q end;local o=function(O)local p=''if O.AstType=='AssignmentStatement'then for P=1,#O.Lhs do p=p..M(O.Lhs[P])if P~=#O.Lhs then p=p..","end end;if#O.Rhs>0 then p=p.."="for P=1,#O.Rhs do p=p..M(O.Rhs[P])if P~=#O.Rhs then p=p..","end end end elseif O.AstType=='CallStatement'then p=M(O.Expression)elseif O.AstType=='LocalStatement'then p=p.."local "for P=1,#O.LocalList do p=p..O.LocalList[P].Name;if P~=#O.LocalList then p=p..","end end;if#O.InitList>0 then p=p.."="for P=1,#O.InitList do p=p..M(O.InitList[P])if P~=#O.InitList then p=p..","end end end elseif O.AstType=='IfStatement'then p=N("if",M(O.Clauses[1].Condition))p=N(p,"then")p=N(p,m(O.Clauses[1].Body))for P=2,#O.Clauses do local q=O.Clauses[P]if q.Condition then p=N(p,"elseif")p=N(p,M(q.Condition))p=N(p,"then")else p=N(p,"else")end;p=N(p,m(q.Body))end;p=N(p,"end")elseif O.AstType=='WhileStatement'then p=N("while",M(O.Condition))p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='DoStatement'then p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='ReturnStatement'then p="return"for P=1,#O.Arguments do p=N(p,M(O.Arguments[P]))if P~=#O.Arguments then p=p..","end end elseif O.AstType=='BreakStatement'then p="break"elseif O.AstType=='RepeatStatement'then p="repeat"p=N(p,m(O.Body))p=N(p,"until")p=N(p,M(O.Condition))elseif O.AstType=='Function'then O.Scope:ObfuscateVariables()if O.IsLocal then p="local"end;p=N(p,"function ")if O.IsLocal then p=p..O.Name.Name else p=p..M(O.Name)end;p=p.."("if#O.Arguments>0 then for P=1,#O.Arguments do p=p..O.Arguments[P].Name;if P~=#O.Arguments then p=p..","elseif O.VarArg then p=p..",..."end end elseif O.VarArg then p=p.."..."end;p=p..")"p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='GenericForStatement'then O.Scope:ObfuscateVariables()p="for "for P=1,#O.VariableList do p=p..O.VariableList[P].Name;if P~=#O.VariableList then p=p..","end end;p=p.." in"for P=1,#O.Generators do p=N(p,M(O.Generators[P]))if P~=#O.Generators then p=N(p,',')end end;p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='NumericForStatement'then O.Scope:ObfuscateVariables()p="for "p=p..O.Variable.Name.."="p=p..M(O.Start)..","..M(O.End)if O.Step then p=p..","..M(O.Step)end;p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='LabelStatement'then p=getIndentation().."::"..O.Label.."::"elseif O.AstType=='GotoStatement'then p=getIndentation().."goto "..O.Label elseif O.AstType=='Comment'then elseif O.AstType=='Eof'then else print("Unknown AST Type: "..O.AstType)end;n=n+#p;return p end;m=function(O)local p=''O.Scope:ObfuscateVariables()for P,q in pairs(O.Body)do p=N(p,o(q),';')end;return p end;L.Scope:ObfuscateVariables()return m(L)end;return l end;f[2]=function()local h=E()f[2]=function()return h end;return h end end;do local E=function()if true then __STRICT=true;function global()end;return end;local h=getmetatable(_G)if h==nil then h={}setmetatable(_G,h)end;__STRICT=true;h.__declared={}h.__newindex=function(H,i,I)if __STRICT and not h.__declared[i]then local j=debug.getinfo(2,"S").what;if j~="main"and j~="C"then error("assign to undeclared variable '"..i.."'",2)end;h.__declared[i]=true end;rawset(H,i,I)end;h.__index=function(H,i)if not h.__declared[i]and debug.getinfo(2,"S").what~="C"then error("variable '"..i.."' is not declared",2)end;return rawget(H,i)end;function global(...)for H,i in ipairs{...}do h.__declared[i]=true end end end;f[4]=function()local h=E()f[4]=function()return h end;return h end end;do local E=function()local function h(J)for k,K in pairs(J)do J[K]=true end;return J end;local function H(J)local k=0;for K in pairs(J)do k=k+1 end;return k end;local function i(J,k)if J.Print then return J.Print()end;k=k or 0;local K=(H(J)>1)local l=string.rep('    ',k+1)local L="{".. (K and'\n'or'')for m,M in pairs(J)do if type(M)~='function'then L=L.. (K and l or'')if type(m)=='number'then elseif type(m)=='string'and m:match("^[A-Za-z_][A-Za-z0-9_]*$")then L=L..m.." = "elseif type(m)=='string'then L=L.."[\""..m.."\"] = "else L=L.."["..tostring(m).."] = "end;if type(M)=='string'then L=L.."\""..M.."\""elseif type(M)=='number'then L=L..M elseif type(M)=='table'then L=L..i(M,k+ (K and 1 or 0))else L=L..tostring(M)end;if next(J,m)then L=L..","end;if K then L=L..'\n'end end end;L=L.. (K and string.rep('    ',k)or'').."}"return L end;local function I(J)if J:match("\n")then local k={}for K in J:gmatch("[^\n]*")do table.insert(k,K)end;assert(#k>0)return k else return{J}end end;local function j(J,...)return print(string.format(J,...))end;return{PrintTable=i,CountTable=H,lookupify=h,splitLines=I,printf=j}end;f[3]=function()local h=E()f[3]=function()return h end;return h end end;do local E=function()f[4]()local h=f[3]()local H=h.lookupify;local i=H{' ','\n','\t','\r'}local I={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'"}local j=H{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local J=H{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local k=H{'0','1','2','3','4','5','6','7','8','9'}local K=H{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}local l=H{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local L=f[5]()local m=H{'and','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'}local function M(N)local o={}local O,p=pcall(function()local r=1;local R=1;local s=1;local function S()local v=N:sub(r,r)if v=='\n'then s=1;R=R+1 else s=s+1 end;r=r+1;return v end;local function t(v)v=v or 0;return N:sub(r+v,r+v)end;local function T(v)local V=t()for w=1,#v do if V==v:sub(w,w)then return S()end end end;local function u(v)return error(">> :"..R..":"..s..": "..v,0)end;local function U()local v=r;if t()=='['then local V=0;local w=1;while t(V+1)=='='do V=V+1 end;if t(V+1)=='['then for y=0,V+1 do S()end;local W=r;while true do if t()==''then u("Expected `]"..string.rep('=',V).."]` near <eof>.",3)end;local y=true;if t()==']'then for Y=1,V do if t(Y)~='='then y=false end end;if t(V+1)~=']'then y=false end else if t()=='['then local Y=true;for z=1,V do if t(z)~='='then Y=false;break end end;if t(V+1)=='['and Y then w=w+1;for z=1,(V+2)do S()end end end;y=false end;if y then w=w-1;if w==0 then break else for Y=1,V+2 do S()end end else S()end end;local x=N:sub(W,r-1)for y=0,V+1 do S()end;local X=N:sub(v,r-1)return x,X else return nil end else return nil end end;while true do local v={}local V=''local w=false;while true do local z=t()if z=='#'and t(1)=='!'and R==1 then S()S()V="#!"while t()~='\n'and t()~=''do V=V..S()end;local Z={Type='Comment',CommentType='Shebang',Data=V,Line=R,Char=s}Z.Print=function()return"<".. (Z.Type..string.rep(' ',7-#Z.Type)).."  ".. (Z.Data or'').." >"end;V=""table.insert(v,Z)end;if z==' 'or z=='\t'then local Z=S()table.insert(v,{Type='Whitespace',Line=R,Char=s,Data=Z})elseif z=='\n'or z=='\r'then local Z=S()if V~=""then local _={Type='Comment',CommentType=w and'LongComment'or'Comment',Data=V,Line=R,Char=s}_.Print=function()return"<".. (_.Type..string.rep(' ',7-#_.Type)).."  ".. (_.Data or'').." >"end;table.insert(v,_)V=""end;table.insert(v,{Type='Whitespace',Line=R,Char=s,Data=Z})elseif z=='-'and t(1)=='-'then S()S()V=V..'--'local Z,_=U()if _ then V=V.._;w=true else while t()~='\n'and t()~=''do V=V..S()end end else break end end;if V~=""then local z={Type='Comment',CommentType=w and'LongComment'or'Comment',Data=V,Line=R,Char=s}z.Print=function()return"<".. (z.Type..string.rep(' ',7-#z.Type)).."  ".. (z.Data or'').." >"end;table.insert(v,z)end;local W=R;local x=s;local X=":"..R..":"..s..":> "local y=t()local Y=nil;if y==''then Y={Type='Eof'}elseif J[y]or j[y]or y=='_'then local z=r;repeat S()y=t()until not(J[y]or j[y]or k[y]or y=='_')local Z=N:sub(z,r-1)if m[Z]then Y={Type='Keyword',Data=Z}else Y={Type='Ident',Data=Z}end elseif k[y]or(t()=='.'and k[t(1)])then local z=r;if y=='0'and t(1)=='x'then S()S()while K[t()]do S()end;if T('Pp')then T('+-')while k[t()]do S()end end else while k[t()]do S()end;if T('.')then while k[t()]do S()end end;if T('Ee')then T('+-')while k[t()]do S()end end end;Y={Type='Number',Data=N:sub(z,r-1)}elseif y=='\''or y=='\"'then local z=r;local Z=S()local _=r;while true do local y=S()if y=='\\'then S()elseif y==Z then break elseif y==''then u("Unfinished string near <eof>")end end;local aa=N:sub(_,r-2)local aA=N:sub(z,r-1)Y={Type='String',Data=aA,Constant=aa}elseif y=='['then local z,Z=U()if Z then Y={Type='String',Data=Z,Constant=z}else S()Y={Type='Symbol',Data='['}end elseif T('>=<')then if T('=')then Y={Type='Symbol',Data=y..'='}else Y={Type='Symbol',Data=y}end elseif T('~')then if T('=')then Y={Type='Symbol',Data='~='}else u("Unexpected symbol `~` in source.",2)end elseif T('.')then if T('.')then if T('.')then Y={Type='Symbol',Data='...'}else Y={Type='Symbol',Data='..'}end else Y={Type='Symbol',Data='.'}end elseif T(':')then if T(':')then Y={Type='Symbol',Data='::'}else Y={Type='Symbol',Data=':'}end elseif l[y]then S()Y={Type='Symbol',Data=y}else local z,Z=U()if z then Y={Type='String',Data=Z,Constant=z}else u("Unexpected Symbol `"..y.."` in source.",2)end end;Y.LeadingWhite=v;Y.Line=W;Y.Char=x;Y.Print=function()return"<".. (Y.Type..string.rep(' ',7-#Y.Type)).."  ".. (Y.Data or'').." >"end;o[#o+1]=Y;if Y.Type=='Eof'then break end end end)if not O then return false,p end;local P={}local q={}local Q=1;function P:getp()return Q end;function P:setp(r)Q=r end;function P:getTokenList()return o end;function P:Peek(r)r=r or 0;return o[math.min(#o,Q+r)]end;function P:Get(r)local R=o[Q]Q=math.min(Q+1,#o)if r then table.insert(r,R)end;return R end;function P:Is(r)return P:Peek().Type==r end;function P:Save()q[#q+1]=Q end;function P:Commit()q[#q]=nil end;function P:Restore()Q=q[#q]q[#q]=nil end;function P:ConsumeSymbol(r,R)local s=self:Peek()if s.Type=='Symbol'then if r then if s.Data==r then self:Get(R)return true else return nil end else self:Get(R)return s end else return nil end end;function P:ConsumeKeyword(r,R)local s=self:Peek()if s.Type=='Keyword'and s.Data==r then self:Get(R)return true else return nil end end;function P:IsKeyword(r)local R=P:Peek()return R.Type=='Keyword'and R.Data==r end;function P:IsSymbol(r)local R=P:Peek()return R.Type=='Symbol'and R.Data==r end;function P:IsEof()return P:Peek().Type=='Eof'end;return true,P end;local function n(N)local r,R;if type(N)~='table'then r,R=M(N)else r,R=true,N end;if not r then return false,R end;local function s(Q)local Y=">> :"..R:Peek().Line..":"..R:Peek().Char..": "..Q.."\n"local z=0;if type(N)=='string'then for Z in N:gmatch("[^\n]*\n?")do if Z:sub(-1,-1)=='\n'then Z=Z:sub(1,-2)end;z=z+1;if z==R:Peek().Line then Y=Y..">> `"..Z:gsub('\t','    ').."`\n"for _=1,R:Peek().Char do local aa=Z:sub(_,_)if aa=='\t'then Y=Y..'    'else Y=Y..' 'end end;Y=Y.."   ^^^^"break end end end;return Y end;local S=0;local t={'_','a','b','c','d'}local function T(Q)local Y=L:new(Q)Y.RenameVars=Y.ObfuscateLocals;Y.ObfuscateVariables=Y.ObfuscateLocals;Y.Print=function()return"<Scope>"end;return Y end;local u;local U;local v,V,w,W;local function x(Q,Y)local z=T(Q)if not R:ConsumeSymbol('(',Y)then return false,s("`(` expected.")end;local Z={}local _=false;while not R:ConsumeSymbol(')',Y)do if R:Is('Ident')then local ab=z:CreateLocal(R:Get(Y).Data)Z[#Z+1]=ab;if not R:ConsumeSymbol(',',Y)then if R:ConsumeSymbol(')',Y)then break else return false,s("`)` expected.")end end elseif R:ConsumeSymbol('...',Y)then _=true;if not R:ConsumeSymbol(')',Y)then return false,s("`...` must be the last argument of a function.")end;break else return false,s("Argument name or `...` expected")end end;local r,aa=U(z)if not r then return false,aa end;if not R:ConsumeKeyword('end',Y)then return false,s("`end` expected after function body")end;local aA={}aA.AstType='Function'aA.Scope=z;aA.Arguments=Z;aA.Body=aa;aA.VarArg=_;aA.Tokens=Y;return true,aA end;function w(Q)local Y={}if R:ConsumeSymbol('(',Y)then local r,z=u(Q)if not r then return false,z end;if not R:ConsumeSymbol(')',Y)then return false,s("`)` Expected.")end;if false then z.ParenCount=(z.ParenCount or 0)+1;return true,z else local Z={}Z.AstType='Parentheses'Z.Inner=z;Z.Tokens=Y;return true,Z end elseif R:Is('Ident')then local z=R:Get(Y)local Z=Q:GetLocal(z.Data)if not Z then Z=Q:GetGlobal(z.Data)if not Z then Z=Q:CreateGlobal(z.Data)else Z.References=Z.References+1 end else Z.References=Z.References+1 end;local _={}_.AstType='VarExpr'_.Name=z.Data;_.Variable=Z;_.Tokens=Y;return true,_ else return false,s("primary expression expected")end end;function W(Q,Y)local r,z=w(Q)if not r then return false,z end;while true do local Z={}if R:IsSymbol('.')or R:IsSymbol(':')then local _=R:Get(Z).Data;if not R:Is('Ident')then return false,s("<Ident> expected.")end;local aa=R:Get(Z)local aA={}aA.AstType='MemberExpr'aA.Base=z;aA.Indexer=_;aA.Ident=aa;aA.Tokens=Z;z=aA elseif not Y and R:ConsumeSymbol('[',Z)then local r,_=u(Q)if not r then return false,_ end;if not R:ConsumeSymbol(']',Z)then return false,s("`]` expected.")end;local aa={}aa.AstType='IndexExpr'aa.Base=z;aa.Index=_;aa.Tokens=Z;z=aa elseif not Y and R:ConsumeSymbol('(',Z)then local _={}while not R:ConsumeSymbol(')',Z)do local r,aA=u(Q)if not r then return false,aA end;_[#_+1]=aA;if not R:ConsumeSymbol(',',Z)then if R:ConsumeSymbol(')',Z)then break else return false,s("`)` Expected.")end end end;local aa={}aa.AstType='CallExpr'aa.Base=z;aa.Arguments=_;aa.Tokens=Z;z=aa elseif not Y and R:Is('String')then local _={}_.AstType='StringCallExpr'_.Base=z;_.Arguments={R:Get(Z)}_.Tokens=Z;z=_ elseif not Y and R:IsSymbol('{')then local r,_=v(Q)if not r then return false,_ end;local aa={}aa.AstType='TableCallExpr'aa.Base=z;aa.Arguments={_}aa.Tokens=Z;z=aa else break end end;return true,z end;function v(Q)local Y={}if R:Is('Number')then local z={}z.AstType='NumberExpr'z.Value=R:Get(Y)z.Tokens=Y;return true,z elseif R:Is('String')then local z={}z.AstType='StringExpr'z.Value=R:Get(Y)z.Tokens=Y;return true,z elseif R:ConsumeKeyword('nil',Y)then local z={}z.AstType='NilExpr'z.Tokens=Y;return true,z elseif R:IsKeyword('false')or R:IsKeyword('true')then local z={}z.AstType='BooleanExpr'z.Value=(R:Get(Y).Data=='true')z.Tokens=Y;return true,z elseif R:ConsumeSymbol('...',Y)then local z={}z.AstType='DotsExpr'z.Tokens=Y;return true,z elseif R:ConsumeSymbol('{',Y)then local z={}z.AstType='ConstructorExpr'z.EntryList={}while true do if R:IsSymbol('[',Y)then R:Get(Y)local r,Z=u(Q)if not r then return false,s("Key Expression Expected")end;if not R:ConsumeSymbol(']',Y)then return false,s("`]` Expected")end;if not R:ConsumeSymbol('=',Y)then return false,s("`=` Expected")end;local r,_=u(Q)if not r then return false,s("Value Expression Expected")end;z.EntryList[#z.EntryList+1]={Type='Key',Key=Z,Value=_}elseif R:Is('Ident')then local Z=R:Peek(1)if Z.Type=='Symbol'and Z.Data=='='then local _=R:Get(Y)if not R:ConsumeSymbol('=',Y)then return false,s("`=` Expected")end;local r,aa=u(Q)if not r then return false,s("Value Expression Expected")end;z.EntryList[#z.EntryList+1]={Type='KeyString',Key=_.Data,Value=aa}else local r,_=u(Q)if not r then return false,s("Value Exected")end;z.EntryList[#z.EntryList+1]={Type='Value',Value=_}end elseif R:ConsumeSymbol('}',Y)then break else local r,Z=u(Q)z.EntryList[#z.EntryList+1]={Type='Value',Value=Z}if not r then return false,s("Value Expected")end end;if R:ConsumeSymbol(';',Y)or R:ConsumeSymbol(',',Y)then elseif R:ConsumeSymbol('}',Y)then break else return false,s("`}` or table entry Expected")end end;z.Tokens=Y;return true,z elseif R:ConsumeKeyword('function',Y)then local r,z=x(Q,Y)if not r then return false,z end;z.IsLocal=true;return true,z else return W(Q)end end;local X=H{'-','not','#'}local y=8;local o={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}function V(Q,Y)local r,z;if X[R:Peek().Data]then local Z={}local _=R:Get(Z).Data;r,z=V(Q,y)if not r then return false,z end;local aa={}aa.AstType='UnopExpr'aa.Rhs=z;aa.Op=_;aa.OperatorPrecedence=y;aa.Tokens=Z;z=aa else r,z=v(Q)if not r then return false,z end end;while true do local Z=o[R:Peek().Data]if Z and Z[1]>Y then local _={}local aa=R:Get(_).Data;local r,aA=V(Q,Z[2])if not r then return false,aA end;local ab={}ab.AstType='BinopExpr'ab.Lhs=z;ab.Op=aa;ab.OperatorPrecedence=Z[1]ab.Rhs=aA;ab.Tokens=_;z=ab else break end end;return true,z end;u=function(Q)return V(Q,0)end;local function O(Q)local Y=nil;local z={}if R:ConsumeKeyword('if',z)then local Z={}Z.AstType='IfStatement'Z.Clauses={}repeat local r,_=u(Q)if not r then return false,_ end;if not R:ConsumeKeyword('then',z)then return false,s("`then` expected.")end;local r,aa=U(Q)if not r then return false,aa end;Z.Clauses[#Z.Clauses+1]={Condition=_,Body=aa}until not R:ConsumeKeyword('elseif',z)if R:ConsumeKeyword('else',z)then local r,_=U(Q)if not r then return false,_ end;Z.Clauses[#Z.Clauses+1]={Body=_}end;if not R:ConsumeKeyword('end',z)then return false,s("`end` expected.")end;Z.Tokens=z;Y=Z elseif R:ConsumeKeyword('while',z)then local Z={}Z.AstType='WhileStatement'local r,_=u(Q)if not r then return false,_ end;if not R:ConsumeKeyword('do',z)then return false,s("`do` expected.")end;local r,aa=U(Q)if not r then return false,aa end;if not R:ConsumeKeyword('end',z)then return false,s("`end` expected.")end;Z.Condition=_;Z.Body=aa;Z.Tokens=z;Y=Z elseif R:ConsumeKeyword('do',z)then local r,Z=U(Q)if not r then return false,Z end;if not R:ConsumeKeyword('end',z)then return false,s("`end` expected.")end;local _={}_.AstType='DoStatement'_.Body=Z;_.Tokens=z;Y=_ elseif R:ConsumeKeyword('for',z)then if not R:Is('Ident')then return false,s("<ident> expected.")end;local Z=R:Get(z)if R:ConsumeSymbol('=',z)then local _=T(Q)local aa=_:CreateLocal(Z.Data)local r,aA=u(Q)if not r then return false,aA end;if not R:ConsumeSymbol(',',z)then return false,s("`,` Expected")end;local r,ab=u(Q)if not r then return false,ab end;local r,aB;if R:ConsumeSymbol(',',z)then r,aB=u(Q)if not r then return false,aB end end;if not R:ConsumeKeyword('do',z)then return false,s("`do` expected")end;local r,ac=U(_)if not r then return false,ac end;if not R:ConsumeKeyword('end',z)then return false,s("`end` expected")end;local aC={}aC.AstType='NumericForStatement'aC.Scope=_;aC.Variable=aa;aC.Start=aA;aC.End=ab;aC.Step=aB;aC.Body=ac;aC.Tokens=z;Y=aC else local _=T(Q)local aa={_:CreateLocal(Z.Data)}while R:ConsumeSymbol(',',z)do if not R:Is('Ident')then return false,s("for variable expected.")end;aa[#aa+1]=_:CreateLocal(R:Get(z).Data)end;if not R:ConsumeKeyword('in',z)then return false,s("`in` expected.")end;local aA={}local r,ab=u(Q)if not r then return false,ab end;aA[#aA+1]=ab;while R:ConsumeSymbol(',',z)do local r,aC=u(Q)if not r then return false,aC end;aA[#aA+1]=aC end;if not R:ConsumeKeyword('do',z)then return false,s("`do` expected.")end;local r,aB=U(_)if not r then return false,aB end;if not R:ConsumeKeyword('end',z)then return false,s("`end` expected.")end;local ac={}ac.AstType='GenericForStatement'ac.Scope=_;ac.VariableList=aa;ac.Generators=aA;ac.Body=aB;ac.Tokens=z;Y=ac end elseif R:ConsumeKeyword('repeat',z)then local r,Z=U(Q)if not r then return false,Z end;if not R:ConsumeKeyword('until',z)then return false,s("`until` expected.")end;local r,_=u(Z.Scope)if not r then return false,_ end;local aa={}aa.AstType='RepeatStatement'aa.Condition=_;aa.Body=Z;aa.Tokens=z;Y=aa elseif R:ConsumeKeyword('function',z)then if not R:Is('Ident')then return false,s("Function name expected")end;local r,Z=W(Q,true)if not r then return false,Z end;local r,_=x(Q,z)if not r then return false,_ end;_.IsLocal=false;_.Name=Z;Y=_ elseif R:ConsumeKeyword('local',z)then if R:Is('Ident')then local Z={R:Get(z).Data}while R:ConsumeSymbol(',',z)do if not R:Is('Ident')then return false,s("local var name expected")end;Z[#Z+1]=R:Get(z).Data end;local _={}if R:ConsumeSymbol('=',z)then repeat local r,aA=u(Q)if not r then return false,aA end;_[#_+1]=aA until not R:ConsumeSymbol(',',z)end;for aA,ab in pairs(Z)do Z[aA]=Q:CreateLocal(ab)end;local aa={}aa.AstType='LocalStatement'aa.LocalList=Z;aa.InitList=_;aa.Tokens=z;Y=aa elseif R:ConsumeKeyword('function',z)then if not R:Is('Ident')then return false,s("Function name expected")end;local Z=R:Get(z).Data;local _=Q:CreateLocal(Z)local r,aa=x(Q,z)if not r then return false,aa end;aa.Name=_;aa.IsLocal=true;Y=aa else return false,s("local var or function def expected")end elseif R:ConsumeSymbol('::',z)then if not R:Is('Ident')then return false,s('Label name expected')end;local Z=R:Get(z).Data;if not R:ConsumeSymbol('::',z)then return false,s("`::` expected")end;local _={}_.AstType='LabelStatement'_.Label=Z;_.Tokens=z;Y=_ elseif R:ConsumeKeyword('return',z)then local Z={}if not R:IsKeyword('end')then local r,aa=u(Q)if r then Z[1]=aa;while R:ConsumeSymbol(',',z)do local r,aA=u(Q)if not r then return false,aA end;Z[#Z+1]=aA end end end;local _={}_.AstType='ReturnStatement'_.Arguments=Z;_.Tokens=z;Y=_ elseif R:ConsumeKeyword('break',z)then local Z={}Z.AstType='BreakStatement'Z.Tokens=z;Y=Z elseif R:ConsumeKeyword('goto',z)then if not R:Is('Ident')then return false,s("Label expected")end;local Z=R:Get(z).Data;local _={}_.AstType='GotoStatement'_.Label=Z;_.Tokens=z;Y=_ else local r,Z=W(Q)if not r then return false,Z end;if R:IsSymbol(',')or R:IsSymbol('=')then if(Z.ParenCount or 0)>0 then return false,s("Can not assign to parenthesized expression, is not an lvalue")end;local _={Z}while R:ConsumeSymbol(',',z)do local r,aB=W(Q)if not r then return false,aB end;_[#_+1]=aB end;if not R:ConsumeSymbol('=',z)then return false,s("`=` Expected.")end;local aa={}local r,aA=u(Q)if not r then return false,aA end;aa[1]=aA;while R:ConsumeSymbol(',',z)do local r,aB=u(Q)if not r then return false,aB end;aa[#aa+1]=aB end;local ab={}ab.AstType='AssignmentStatement'ab.Lhs=_;ab.Rhs=aa;ab.Tokens=z;Y=ab elseif Z.AstType=='CallExpr'or Z.AstType=='TableCallExpr'or Z.AstType=='StringCallExpr'then local _={}_.AstType='CallStatement'_.Expression=Z;_.Tokens=z;Y=_ else return false,s("Assignment Statement Expected")end end;if R:IsSymbol(';')then Y.Semicolon=R:Get(Y.Tokens)end;return true,Y end;local p=H{'end','else','elseif','until'}U=function(Q)local Y={}Y.Scope=T(Q)Y.AstType='Statlist'Y.Body={}Y.Tokens={}while not p[R:Peek().Data]and not R:IsEof()do local r,z=O(Y.Scope)if not r then return false,z end;Y.Body[#Y.Body+1]=z end;if R:IsEof()then local z={}z.AstType='Eof'z.Tokens={R:Get()}Y.Body[#Y.Body+1]=z end;return true,Y end;local function P()local Q=T()return U(Q)end;local r,q=P()return r,q end;return{LexLua=M,ParseLua=n}end;f[1]=function()local h=E()f[1]=function()return h end;return h end end;local F=f[1]()local G=f[2]()local g=F.ParseLua;local a={}local function A(E)return E:match("(.*/)")or"./"end;local function b(E)E=E:gsub("\\","/")E=E:gsub("//","/")local h={}for H in E:gmatch("[^/]+")do if H==".."then table.remove(h)elseif H~="."then table.insert(h,H)end end;return table.concat(h,"/")end;local function B(E,h)h=h and(h:match("/$")and h or h.."/")or""local H={E,h..E,h..E..".lua",h..E..".luau"}for I,j in ipairs(H)do local i=io.open(j,"r")if i then local J=i:read("*all")i:close()return J,j end end;return nil end;function a.bundle(E,K,l,h,H,i,I,j,J)for L,n in next,J do E=E:gsub(L,function()return n end)end;E=a.minifyLua(E)K=K or K==nil;l=l or nil;H=H or{}i=i or{}local k={}j=j or 1;I=I==nil and"__MODULES_"..a.makeid(25)or I;local function m(L)local function n(N)local P;local q,o=pcall(function()P=io.open(h..N,"r")or io.open(h..N..".lua","r")or io.open(h..N..".luau","r")end)if not q or not P then return("require\"%s\""):format(N)end;P:close()local O=H[N]or j;if not H[N]then H[N]=j;j=j+1 end;if l then k[l]=k[l]or{}table.insert(k[l],N)end;return I.."["..O.."]()"end;L=L:gsub('require%s*[%(%s]*([%\'"%[])(.-)%1[%)%s]*',function(o,O)return n(O)end)return L end;local M=m(E)for L,n in pairs(H)do if not i[L]then local N=B(L,h)if N then i[L]=N;local o=a.bundle(N,false,L,h,H,i,I,j,J)i[L]=o else print("WARNING: Failed to read module "..L)end end end;if K then local L=string.format([[
local %s = {}
]],I)for N,o in pairs(H)do L=L..string.format([[
do
    local module = function()
        %s
    end
    %s[%d] = function()
        local ret = module()
        %s[%d] = function() return ret end
        return ret
    end
end
]],i[N],I,o,I,o)end;M=L..M end;return M end;function a.makeid(E)local I="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"local j="0123456789"local h=""local H=true;for i=1,E do local k=H and I or(I..j)local K=math.random(#k)h=h..k:sub(K,K)H=false end;return h end;function a.removeComments(E)E=E:gsub("%-%-.-\n","\n")E=E:gsub("%-%-%[%[.-%]%]","")return E end;function a.minifyLua(E)local H,i=g(E)if not H then error(i)return end;return G(i)end;function a.writeFile(E,h)local H=io.open(E,"w")if not H then return false end;H:write(h)H:close()return true end;function a.main(E,H,i)E=E or"main.lua"H=H or"bundled.min.lua"local h,J=B(E)if not h then print("ERROR: Cannot read "..E)return false end;local k=a.bundle(h,true,nil,A(J),nil,nil,nil,nil,i)local I=a.minifyLua(k)if a.writeFile(H,I)then print("Bundling and minification completed successfully.")return true else print("Failed to write "..H)return false end end;math.randomseed(os.time())local c={...}if#c<1 then error("Usage: bundle.lua [entrypoint] [?-o output]")end;local C=c[1]local d=""do local E={}for h in C:gmatch("([^.]+)")do table.insert(E,h)end;if#E>1 and E[#E]=="lua"then table.remove(E,#E)end;d=table.concat(E,".")end;local D=d..".min.lua"local e={}for E=2,#c-1 do if c[E]:lower()=="-o"then D=c[E+1]E=E+1 elseif c[E]:lower()=="-d"then local H,i=c[E+1]:match("(%w+)%s*=%s*(.-)%s*$")if type(H)=="string"and type(i)=="string"then e[H]=i end end end;a.main(C,D,e)