local G={}local a=setmetatable({},{__index=function(g,h)local H=rawget(G,h)if H==nil then error("Module not found: "..tostring(h))end;return H end,__newindex=function(g,h,H)local i=rawget(G,h)if i==nil then return rawset(G,h,H)end;if type(i)=="table"or type(i)=="userdata"then if type(H)=="function"then local I=getmetatable(i)if I then I.__call=function(j,...)return H(...)end else setmetatable(i,{__call=function(j,...)return H(...)end})end elseif type(H)=="table"or type(H)=="userdata"then for J,k in next,i do i[J]=nil end;for J,k in next,H do i[J]=k end;local I={}local j=getmetatable(H)if j then for J,k in next,j do I[J]=k end end;I.__index=function(J,h)return H[h]end;I.__newindex=function(J,h,k)H[h]=k end end end;rawset(G,h,H)end})a[2]={}a[1]={}do local g=function()local h=require'ParseLua'local H=h.ParseLua;local i=require'Util'local I=i.lookupify;local j=I{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local J=I{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local k=I{'0','1','2','3','4','5','6','7','8','9'}local K=I{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local function l(L)local m,M;local n=0;local function N(O,p,P)P=P or' 'local q,Q=O:sub(-1,-1),p:sub(1,1)if J[q]or j[q]or q=='_'then if not(J[Q]or j[Q]or Q=='_'or k[Q])then return O..p elseif Q=='('then print("==============>>>",q,Q)return O..P..p else return O..P..p end elseif k[q]then if Q=='('then return O..p elseif K[Q]then return O..p else return O..P..p end elseif q==''then return O..p else if Q=='('then return O..P..p else return O..p end end end;M=function(O,p)local p=p or 0;local P=0;local q=false;local Q=""if O.AstType=='VarExpr'then if O.Variable then Q=Q..O.Variable.Name else Q=Q..O.Name end elseif O.AstType=='NumberExpr'then Q=Q..O.Value.Data elseif O.AstType=='StringExpr'then Q=Q..O.Value.Data elseif O.AstType=='BooleanExpr'then Q=Q..tostring(O.Value)elseif O.AstType=='NilExpr'then Q=N(Q,"nil")elseif O.AstType=='BinopExpr'then P=O.OperatorPrecedence;Q=N(Q,M(O.Lhs,P))Q=N(Q,O.Op)Q=N(Q,M(O.Rhs))if O.Op=='^'or O.Op=='..'then P=P-1 end;if P<p then q=false else q=true end elseif O.AstType=='UnopExpr'then Q=N(Q,O.Op)Q=N(Q,M(O.Rhs))elseif O.AstType=='DotsExpr'then Q=Q.."..."elseif O.AstType=='CallExpr'then Q=Q..M(O.Base)Q=Q.."("for r=1,#O.Arguments do Q=Q..M(O.Arguments[r])if r~=#O.Arguments then Q=Q..","end end;Q=Q..")"elseif O.AstType=='TableCallExpr'then Q=Q..M(O.Base)Q=Q..M(O.Arguments[1])elseif O.AstType=='StringCallExpr'then Q=Q..M(O.Base)Q=Q..O.Arguments[1].Data elseif O.AstType=='IndexExpr'then Q=Q..M(O.Base).."["..M(O.Index).."]"elseif O.AstType=='MemberExpr'then Q=Q..M(O.Base)..O.Indexer..O.Ident.Data elseif O.AstType=='Function'then O.Scope:ObfuscateVariables()Q=Q.."function("if#O.Arguments>0 then for r=1,#O.Arguments do Q=Q..O.Arguments[r].Name;if r~=#O.Arguments then Q=Q..","elseif O.VarArg then Q=Q..",..."end end elseif O.VarArg then Q=Q.."..."end;Q=Q..")"Q=N(Q,m(O.Body))Q=N(Q,"end")elseif O.AstType=='ConstructorExpr'then Q=Q.."{"for r=1,#O.EntryList do local R=O.EntryList[r]if R.Type=='Key'then Q=Q.."["..M(R.Key).."]="..M(R.Value)elseif R.Type=='Value'then Q=Q..M(R.Value)elseif R.Type=='KeyString'then Q=Q..R.Key.."="..M(R.Value)end;if r~=#O.EntryList then Q=Q..","end end;Q=Q.."}"elseif O.AstType=='Parentheses'then Q=Q.."("..M(O.Inner)..")"end;if not q then Q=string.rep('(',O.ParenCount or 0)..Q;Q=Q..string.rep(')',O.ParenCount or 0)end;n=n+#Q;return Q end;local o=function(O)local p=''if O.AstType=='AssignmentStatement'then for P=1,#O.Lhs do p=p..M(O.Lhs[P])if P~=#O.Lhs then p=p..","end end;if#O.Rhs>0 then p=p.."="for P=1,#O.Rhs do p=p..M(O.Rhs[P])if P~=#O.Rhs then p=p..","end end end elseif O.AstType=='CallStatement'then p=M(O.Expression)elseif O.AstType=='LocalStatement'then p=p.."local "for P=1,#O.LocalList do p=p..O.LocalList[P].Name;if P~=#O.LocalList then p=p..","end end;if#O.InitList>0 then p=p.."="for P=1,#O.InitList do p=p..M(O.InitList[P])if P~=#O.InitList then p=p..","end end end elseif O.AstType=='IfStatement'then p=N("if",M(O.Clauses[1].Condition))p=N(p,"then")p=N(p,m(O.Clauses[1].Body))for P=2,#O.Clauses do local q=O.Clauses[P]if q.Condition then p=N(p,"elseif")p=N(p,M(q.Condition))p=N(p,"then")else p=N(p,"else")end;p=N(p,m(q.Body))end;p=N(p,"end")elseif O.AstType=='WhileStatement'then p=N("while",M(O.Condition))p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='DoStatement'then p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='ReturnStatement'then p="return"for P=1,#O.Arguments do p=N(p,M(O.Arguments[P]))if P~=#O.Arguments then p=p..","end end elseif O.AstType=='BreakStatement'then p="break"elseif O.AstType=='RepeatStatement'then p="repeat"p=N(p,m(O.Body))p=N(p,"until")p=N(p,M(O.Condition))elseif O.AstType=='Function'then O.Scope:ObfuscateVariables()if O.IsLocal then p="local"end;p=N(p,"function ")if O.IsLocal then p=p..O.Name.Name else p=p..M(O.Name)end;p=p.."("if#O.Arguments>0 then for P=1,#O.Arguments do p=p..O.Arguments[P].Name;if P~=#O.Arguments then p=p..","elseif O.VarArg then p=p..",..."end end elseif O.VarArg then p=p.."..."end;p=p..")"p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='GenericForStatement'then O.Scope:ObfuscateVariables()p="for "for P=1,#O.VariableList do p=p..O.VariableList[P].Name;if P~=#O.VariableList then p=p..","end end;p=p.." in"for P=1,#O.Generators do p=N(p,M(O.Generators[P]))if P~=#O.Generators then p=N(p,',')end end;p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='NumericForStatement'then O.Scope:ObfuscateVariables()p="for "p=p..O.Variable.Name.."="p=p..M(O.Start)..","..M(O.End)if O.Step then p=p..","..M(O.Step)end;p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='LabelStatement'then p=getIndentation().."::"..O.Label.."::"elseif O.AstType=='GotoStatement'then p=getIndentation().."goto "..O.Label elseif O.AstType=='Comment'then elseif O.AstType=='Eof'then else print("Unknown AST Type: "..O.AstType)end;n=n+#p;return p end;m=function(O)local p=''O.Scope:ObfuscateVariables()for P,q in pairs(O.Body)do p=N(p,o(q),';')end;return p end;L.Scope:ObfuscateVariables()return m(L)end;return l end;a[2]=g()end;do local g=function()require'strict'local h=require'Util'local H=h.lookupify;local i=H{' ','\n','\t','\r'}local I={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'"}local j=H{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local J=H{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local k=H{'0','1','2','3','4','5','6','7','8','9'}local K=H{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}local l=H{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local L=require'Scope'local m=H{'and','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'}local function M(N)local o={}local O,P=pcall(function()local R=1;local p=1;local s=1;local function S()local v=N:sub(R,R)if v=='\n'then s=1;p=p+1 else s=s+1 end;R=R+1;return v end;local function t(v)v=v or 0;return N:sub(R+v,R+v)end;local function T(v)local V=t()for w=1,#v do if V==v:sub(w,w)then return S()end end end;local function u(v)return error(">> :"..p..":"..s..": "..v,0)end;local function U()local v=R;if t()=='['then local V=0;local w=1;while t(V+1)=='='do V=V+1 end;if t(V+1)=='['then for y=0,V+1 do S()end;local W=R;while true do if t()==''then u("Expected `]"..string.rep('=',V).."]` near <eof>.",3)end;local y=true;if t()==']'then for Y=1,V do if t(Y)~='='then y=false end end;if t(V+1)~=']'then y=false end else if t()=='['then local Y=true;for z=1,V do if t(z)~='='then Y=false;break end end;if t(V+1)=='['and Y then w=w+1;for z=1,(V+2)do S()end end end;y=false end;if y then w=w-1;if w==0 then break else for Y=1,V+2 do S()end end else S()end end;local x=N:sub(W,R-1)for y=0,V+1 do S()end;local X=N:sub(v,R-1)return x,X else return nil end else return nil end end;while true do local v={}local V=''local w=false;while true do local z=t()if z=='#'and t(1)=='!'and p==1 then S()S()V="#!"while t()~='\n'and t()~=''do V=V..S()end;local Z={Type='Comment',CommentType='Shebang',Data=V,Line=p,Char=s}Z.Print=function()return"<".. (Z.Type..string.rep(' ',7-#Z.Type)).."  ".. (Z.Data or'').." >"end;V=""table.insert(v,Z)end;if z==' 'or z=='\t'then local Z=S()table.insert(v,{Type='Whitespace',Line=p,Char=s,Data=Z})elseif z=='\n'or z=='\r'then local Z=S()if V~=""then local _={Type='Comment',CommentType=w and'LongComment'or'Comment',Data=V,Line=p,Char=s}_.Print=function()return"<".. (_.Type..string.rep(' ',7-#_.Type)).."  ".. (_.Data or'').." >"end;table.insert(v,_)V=""end;table.insert(v,{Type='Whitespace',Line=p,Char=s,Data=Z})elseif z=='-'and t(1)=='-'then S()S()V=V..'--'local Z,_=U()if _ then V=V.._;w=true else while t()~='\n'and t()~=''do V=V..S()end end else break end end;if V~=""then local z={Type='Comment',CommentType=w and'LongComment'or'Comment',Data=V,Line=p,Char=s}z.Print=function()return"<".. (z.Type..string.rep(' ',7-#z.Type)).."  ".. (z.Data or'').." >"end;table.insert(v,z)end;local W=p;local x=s;local X=":"..p..":"..s..":> "local y=t()local Y=nil;if y==''then Y={Type='Eof'}elseif J[y]or j[y]or y=='_'then local z=R;repeat S()y=t()until not(J[y]or j[y]or k[y]or y=='_')local Z=N:sub(z,R-1)if m[Z]then Y={Type='Keyword',Data=Z}else Y={Type='Ident',Data=Z}end elseif k[y]or(t()=='.'and k[t(1)])then local z=R;if y=='0'and t(1)=='x'then S()S()while K[t()]do S()end;if T('Pp')then T('+-')while k[t()]do S()end end else while k[t()]do S()end;if T('.')then while k[t()]do S()end end;if T('Ee')then T('+-')while k[t()]do S()end end end;Y={Type='Number',Data=N:sub(z,R-1)}elseif y=='\''or y=='\"'then local z=R;local Z=S()local _=R;while true do local y=S()if y=='\\'then S()elseif y==Z then break elseif y==''then u("Unfinished string near <eof>")end end;local aa=N:sub(_,R-2)local aA=N:sub(z,R-1)Y={Type='String',Data=aA,Constant=aa}elseif y=='['then local z,Z=U()if Z then Y={Type='String',Data=Z,Constant=z}else S()Y={Type='Symbol',Data='['}end elseif T('>=<')then if T('=')then Y={Type='Symbol',Data=y..'='}else Y={Type='Symbol',Data=y}end elseif T('~')then if T('=')then Y={Type='Symbol',Data='~='}else u("Unexpected symbol `~` in source.",2)end elseif T('.')then if T('.')then if T('.')then Y={Type='Symbol',Data='...'}else Y={Type='Symbol',Data='..'}end else Y={Type='Symbol',Data='.'}end elseif T(':')then if T(':')then Y={Type='Symbol',Data='::'}else Y={Type='Symbol',Data=':'}end elseif l[y]then S()Y={Type='Symbol',Data=y}else local z,Z=U()if z then Y={Type='String',Data=Z,Constant=z}else u("Unexpected Symbol `"..y.."` in source.",2)end end;Y.LeadingWhite=v;Y.Line=W;Y.Char=x;Y.Print=function()return"<".. (Y.Type..string.rep(' ',7-#Y.Type)).."  ".. (Y.Data or'').." >"end;o[#o+1]=Y;if Y.Type=='Eof'then break end end end)if not O then return false,P end;local q={}local Q={}local r=1;function q:getp()return r end;function q:setp(p)r=p end;function q:getTokenList()return o end;function q:Peek(p)p=p or 0;return o[math.min(#o,r+p)]end;function q:Get(p)local R=o[r]r=math.min(r+1,#o)if p then table.insert(p,R)end;return R end;function q:Is(p)return q:Peek().Type==p end;function q:Save()Q[#Q+1]=r end;function q:Commit()Q[#Q]=nil end;function q:Restore()r=Q[#Q]Q[#Q]=nil end;function q:ConsumeSymbol(p,R)local s=self:Peek()if s.Type=='Symbol'then if p then if s.Data==p then self:Get(R)return true else return nil end else self:Get(R)return s end else return nil end end;function q:ConsumeKeyword(p,R)local s=self:Peek()if s.Type=='Keyword'and s.Data==p then self:Get(R)return true else return nil end end;function q:IsKeyword(p)local R=q:Peek()return R.Type=='Keyword'and R.Data==p end;function q:IsSymbol(p)local R=q:Peek()return R.Type=='Symbol'and R.Data==p end;function q:IsEof()return q:Peek().Type=='Eof'end;return true,q end;local function n(N)local o,O;if type(N)~='table'then o,O=M(N)else o,O=true,N end;if not o then return false,O end;local function p(y)local Y=">> :"..O:Peek().Line..":"..O:Peek().Char..": "..y.."\n"local z=0;if type(N)=='string'then for Z in N:gmatch("[^\n]*\n?")do if Z:sub(-1,-1)=='\n'then Z=Z:sub(1,-2)end;z=z+1;if z==O:Peek().Line then Y=Y..">> `"..Z:gsub('\t','    ').."`\n"for _=1,O:Peek().Char do local aa=Z:sub(_,_)if aa=='\t'then Y=Y..'    'else Y=Y..' 'end end;Y=Y.."   ^^^^"break end end end;return Y end;local P=0;local q={'_','a','b','c','d'}local function Q(y)local Y=L:new(y)Y.RenameVars=Y.ObfuscateLocals;Y.ObfuscateVariables=Y.ObfuscateLocals;Y.Print=function()return"<Scope>"end;return Y end;local r;local R;local s,S,t,T;local function u(y,Y)local z=Q(y)if not O:ConsumeSymbol('(',Y)then return false,p("`(` expected.")end;local Z={}local _=false;while not O:ConsumeSymbol(')',Y)do if O:Is('Ident')then local ab=z:CreateLocal(O:Get(Y).Data)Z[#Z+1]=ab;if not O:ConsumeSymbol(',',Y)then if O:ConsumeSymbol(')',Y)then break else return false,p("`)` expected.")end end elseif O:ConsumeSymbol('...',Y)then _=true;if not O:ConsumeSymbol(')',Y)then return false,p("`...` must be the last argument of a function.")end;break else return false,p("Argument name or `...` expected")end end;local o,aa=R(z)if not o then return false,aa end;if not O:ConsumeKeyword('end',Y)then return false,p("`end` expected after function body")end;local aA={}aA.AstType='Function'aA.Scope=z;aA.Arguments=Z;aA.Body=aa;aA.VarArg=_;aA.Tokens=Y;return true,aA end;function t(y)local Y={}if O:ConsumeSymbol('(',Y)then local o,z=r(y)if not o then return false,z end;if not O:ConsumeSymbol(')',Y)then return false,p("`)` Expected.")end;if false then z.ParenCount=(z.ParenCount or 0)+1;return true,z else local Z={}Z.AstType='Parentheses'Z.Inner=z;Z.Tokens=Y;return true,Z end elseif O:Is('Ident')then local z=O:Get(Y)local Z=y:GetLocal(z.Data)if not Z then Z=y:GetGlobal(z.Data)if not Z then Z=y:CreateGlobal(z.Data)else Z.References=Z.References+1 end else Z.References=Z.References+1 end;local _={}_.AstType='VarExpr'_.Name=z.Data;_.Variable=Z;_.Tokens=Y;return true,_ else return false,p("primary expression expected")end end;function T(y,Y)local o,z=t(y)if not o then return false,z end;while true do local Z={}if O:IsSymbol('.')or O:IsSymbol(':')then local _=O:Get(Z).Data;if not O:Is('Ident')then return false,p("<Ident> expected.")end;local aa=O:Get(Z)local aA={}aA.AstType='MemberExpr'aA.Base=z;aA.Indexer=_;aA.Ident=aa;aA.Tokens=Z;z=aA elseif not Y and O:ConsumeSymbol('[',Z)then local o,_=r(y)if not o then return false,_ end;if not O:ConsumeSymbol(']',Z)then return false,p("`]` expected.")end;local aa={}aa.AstType='IndexExpr'aa.Base=z;aa.Index=_;aa.Tokens=Z;z=aa elseif not Y and O:ConsumeSymbol('(',Z)then local _={}while not O:ConsumeSymbol(')',Z)do local o,aA=r(y)if not o then return false,aA end;_[#_+1]=aA;if not O:ConsumeSymbol(',',Z)then if O:ConsumeSymbol(')',Z)then break else return false,p("`)` Expected.")end end end;local aa={}aa.AstType='CallExpr'aa.Base=z;aa.Arguments=_;aa.Tokens=Z;z=aa elseif not Y and O:Is('String')then local _={}_.AstType='StringCallExpr'_.Base=z;_.Arguments={O:Get(Z)}_.Tokens=Z;z=_ elseif not Y and O:IsSymbol('{')then local o,_=s(y)if not o then return false,_ end;local aa={}aa.AstType='TableCallExpr'aa.Base=z;aa.Arguments={_}aa.Tokens=Z;z=aa else break end end;return true,z end;function s(y)local Y={}if O:Is('Number')then local z={}z.AstType='NumberExpr'z.Value=O:Get(Y)z.Tokens=Y;return true,z elseif O:Is('String')then local z={}z.AstType='StringExpr'z.Value=O:Get(Y)z.Tokens=Y;return true,z elseif O:ConsumeKeyword('nil',Y)then local z={}z.AstType='NilExpr'z.Tokens=Y;return true,z elseif O:IsKeyword('false')or O:IsKeyword('true')then local z={}z.AstType='BooleanExpr'z.Value=(O:Get(Y).Data=='true')z.Tokens=Y;return true,z elseif O:ConsumeSymbol('...',Y)then local z={}z.AstType='DotsExpr'z.Tokens=Y;return true,z elseif O:ConsumeSymbol('{',Y)then local z={}z.AstType='ConstructorExpr'z.EntryList={}while true do if O:IsSymbol('[',Y)then O:Get(Y)local o,Z=r(y)if not o then return false,p("Key Expression Expected")end;if not O:ConsumeSymbol(']',Y)then return false,p("`]` Expected")end;if not O:ConsumeSymbol('=',Y)then return false,p("`=` Expected")end;local o,_=r(y)if not o then return false,p("Value Expression Expected")end;z.EntryList[#z.EntryList+1]={Type='Key',Key=Z,Value=_}elseif O:Is('Ident')then local Z=O:Peek(1)if Z.Type=='Symbol'and Z.Data=='='then local _=O:Get(Y)if not O:ConsumeSymbol('=',Y)then return false,p("`=` Expected")end;local o,aa=r(y)if not o then return false,p("Value Expression Expected")end;z.EntryList[#z.EntryList+1]={Type='KeyString',Key=_.Data,Value=aa}else local o,_=r(y)if not o then return false,p("Value Exected")end;z.EntryList[#z.EntryList+1]={Type='Value',Value=_}end elseif O:ConsumeSymbol('}',Y)then break else local o,Z=r(y)z.EntryList[#z.EntryList+1]={Type='Value',Value=Z}if not o then return false,p("Value Expected")end end;if O:ConsumeSymbol(';',Y)or O:ConsumeSymbol(',',Y)then elseif O:ConsumeSymbol('}',Y)then break else return false,p("`}` or table entry Expected")end end;z.Tokens=Y;return true,z elseif O:ConsumeKeyword('function',Y)then local o,z=u(y,Y)if not o then return false,z end;z.IsLocal=true;return true,z else return T(y)end end;local U=H{'-','not','#'}local v=8;local V={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}function S(y,Y)local o,z;if U[O:Peek().Data]then local Z={}local _=O:Get(Z).Data;o,z=S(y,v)if not o then return false,z end;local aa={}aa.AstType='UnopExpr'aa.Rhs=z;aa.Op=_;aa.OperatorPrecedence=v;aa.Tokens=Z;z=aa else o,z=s(y)if not o then return false,z end end;while true do local Z=V[O:Peek().Data]if Z and Z[1]>Y then local _={}local aa=O:Get(_).Data;local o,aA=S(y,Z[2])if not o then return false,aA end;local ab={}ab.AstType='BinopExpr'ab.Lhs=z;ab.Op=aa;ab.OperatorPrecedence=Z[1]ab.Rhs=aA;ab.Tokens=_;z=ab else break end end;return true,z end;r=function(y)return S(y,0)end;local function w(y)local Y=nil;local z={}if O:ConsumeKeyword('if',z)then local Z={}Z.AstType='IfStatement'Z.Clauses={}repeat local o,_=r(y)if not o then return false,_ end;if not O:ConsumeKeyword('then',z)then return false,p("`then` expected.")end;local o,aa=R(y)if not o then return false,aa end;Z.Clauses[#Z.Clauses+1]={Condition=_,Body=aa}until not O:ConsumeKeyword('elseif',z)if O:ConsumeKeyword('else',z)then local o,_=R(y)if not o then return false,_ end;Z.Clauses[#Z.Clauses+1]={Body=_}end;if not O:ConsumeKeyword('end',z)then return false,p("`end` expected.")end;Z.Tokens=z;Y=Z elseif O:ConsumeKeyword('while',z)then local Z={}Z.AstType='WhileStatement'local o,_=r(y)if not o then return false,_ end;if not O:ConsumeKeyword('do',z)then return false,p("`do` expected.")end;local o,aa=R(y)if not o then return false,aa end;if not O:ConsumeKeyword('end',z)then return false,p("`end` expected.")end;Z.Condition=_;Z.Body=aa;Z.Tokens=z;Y=Z elseif O:ConsumeKeyword('do',z)then local o,Z=R(y)if not o then return false,Z end;if not O:ConsumeKeyword('end',z)then return false,p("`end` expected.")end;local _={}_.AstType='DoStatement'_.Body=Z;_.Tokens=z;Y=_ elseif O:ConsumeKeyword('for',z)then if not O:Is('Ident')then return false,p("<ident> expected.")end;local Z=O:Get(z)if O:ConsumeSymbol('=',z)then local _=Q(y)local aa=_:CreateLocal(Z.Data)local o,aA=r(y)if not o then return false,aA end;if not O:ConsumeSymbol(',',z)then return false,p("`,` Expected")end;local o,ab=r(y)if not o then return false,ab end;local o,aB;if O:ConsumeSymbol(',',z)then o,aB=r(y)if not o then return false,aB end end;if not O:ConsumeKeyword('do',z)then return false,p("`do` expected")end;local o,ac=R(_)if not o then return false,ac end;if not O:ConsumeKeyword('end',z)then return false,p("`end` expected")end;local aC={}aC.AstType='NumericForStatement'aC.Scope=_;aC.Variable=aa;aC.Start=aA;aC.End=ab;aC.Step=aB;aC.Body=ac;aC.Tokens=z;Y=aC else local _=Q(y)local aa={_:CreateLocal(Z.Data)}while O:ConsumeSymbol(',',z)do if not O:Is('Ident')then return false,p("for variable expected.")end;aa[#aa+1]=_:CreateLocal(O:Get(z).Data)end;if not O:ConsumeKeyword('in',z)then return false,p("`in` expected.")end;local aA={}local o,ab=r(y)if not o then return false,ab end;aA[#aA+1]=ab;while O:ConsumeSymbol(',',z)do local o,aC=r(y)if not o then return false,aC end;aA[#aA+1]=aC end;if not O:ConsumeKeyword('do',z)then return false,p("`do` expected.")end;local o,aB=R(_)if not o then return false,aB end;if not O:ConsumeKeyword('end',z)then return false,p("`end` expected.")end;local ac={}ac.AstType='GenericForStatement'ac.Scope=_;ac.VariableList=aa;ac.Generators=aA;ac.Body=aB;ac.Tokens=z;Y=ac end elseif O:ConsumeKeyword('repeat',z)then local o,Z=R(y)if not o then return false,Z end;if not O:ConsumeKeyword('until',z)then return false,p("`until` expected.")end;local o,_=r(Z.Scope)if not o then return false,_ end;local aa={}aa.AstType='RepeatStatement'aa.Condition=_;aa.Body=Z;aa.Tokens=z;Y=aa elseif O:ConsumeKeyword('function',z)then if not O:Is('Ident')then return false,p("Function name expected")end;local o,Z=T(y,true)if not o then return false,Z end;local o,_=u(y,z)if not o then return false,_ end;_.IsLocal=false;_.Name=Z;Y=_ elseif O:ConsumeKeyword('local',z)then if O:Is('Ident')then local Z={O:Get(z).Data}while O:ConsumeSymbol(',',z)do if not O:Is('Ident')then return false,p("local var name expected")end;Z[#Z+1]=O:Get(z).Data end;local _={}if O:ConsumeSymbol('=',z)then repeat local o,aA=r(y)if not o then return false,aA end;_[#_+1]=aA until not O:ConsumeSymbol(',',z)end;for aA,ab in pairs(Z)do Z[aA]=y:CreateLocal(ab)end;local aa={}aa.AstType='LocalStatement'aa.LocalList=Z;aa.InitList=_;aa.Tokens=z;Y=aa elseif O:ConsumeKeyword('function',z)then if not O:Is('Ident')then return false,p("Function name expected")end;local Z=O:Get(z).Data;local _=y:CreateLocal(Z)local o,aa=u(y,z)if not o then return false,aa end;aa.Name=_;aa.IsLocal=true;Y=aa else return false,p("local var or function def expected")end elseif O:ConsumeSymbol('::',z)then if not O:Is('Ident')then return false,p('Label name expected')end;local Z=O:Get(z).Data;if not O:ConsumeSymbol('::',z)then return false,p("`::` expected")end;local _={}_.AstType='LabelStatement'_.Label=Z;_.Tokens=z;Y=_ elseif O:ConsumeKeyword('return',z)then local Z={}if not O:IsKeyword('end')then local o,aa=r(y)if o then Z[1]=aa;while O:ConsumeSymbol(',',z)do local o,aA=r(y)if not o then return false,aA end;Z[#Z+1]=aA end end end;local _={}_.AstType='ReturnStatement'_.Arguments=Z;_.Tokens=z;Y=_ elseif O:ConsumeKeyword('break',z)then local Z={}Z.AstType='BreakStatement'Z.Tokens=z;Y=Z elseif O:ConsumeKeyword('goto',z)then if not O:Is('Ident')then return false,p("Label expected")end;local Z=O:Get(z).Data;local _={}_.AstType='GotoStatement'_.Label=Z;_.Tokens=z;Y=_ else local o,Z=T(y)if not o then return false,Z end;if O:IsSymbol(',')or O:IsSymbol('=')then if(Z.ParenCount or 0)>0 then return false,p("Can not assign to parenthesized expression, is not an lvalue")end;local _={Z}while O:ConsumeSymbol(',',z)do local o,aB=T(y)if not o then return false,aB end;_[#_+1]=aB end;if not O:ConsumeSymbol('=',z)then return false,p("`=` Expected.")end;local aa={}local o,aA=r(y)if not o then return false,aA end;aa[1]=aA;while O:ConsumeSymbol(',',z)do local o,aB=r(y)if not o then return false,aB end;aa[#aa+1]=aB end;local ab={}ab.AstType='AssignmentStatement'ab.Lhs=_;ab.Rhs=aa;ab.Tokens=z;Y=ab elseif Z.AstType=='CallExpr'or Z.AstType=='TableCallExpr'or Z.AstType=='StringCallExpr'then local _={}_.AstType='CallStatement'_.Expression=Z;_.Tokens=z;Y=_ else return false,p("Assignment Statement Expected")end end;if O:IsSymbol(';')then Y.Semicolon=O:Get(Y.Tokens)end;return true,Y end;local W=H{'end','else','elseif','until'}R=function(y)local Y={}Y.Scope=Q(y)Y.AstType='Statlist'Y.Body={}Y.Tokens={}while not W[O:Peek().Data]and not O:IsEof()do local o,z=w(Y.Scope)if not o then return false,z end;Y.Body[#Y.Body+1]=z end;if O:IsEof()then local z={}z.AstType='Eof'z.Tokens={O:Get()}Y.Body[#Y.Body+1]=z end;return true,Y end;local function x()local y=Q()return R(y)end;local o,X=x()return o,X end;return{LexLua=M,ParseLua=n}end;a[1]=g()end;local A=a[1]local b=a[2]local B=A.ParseLua;local c={}local function C(g)return g:match("(.*/)")or"./"end;local function d(g)g=g:gsub("\\","/")g=g:gsub("//","/")local h={}for H in g:gmatch("[^/]+")do if H==".."then table.remove(h)elseif H~="."then table.insert(h,H)end end;return table.concat(h,"/")end;local function D(g,h)h=h and(h:match("/$")and h or h.."/")or""local H={g,h..g,h..g..".lua"}for i,I in ipairs(H)do local j=io.open(I,"r")if j then local J=j:read("*all")j:close()return J,I end end;return nil end;function c.bundle(g,h,H,i,I,j,J,k)h=h or h==nil;H=H or nil;I=I or{}j=j or{}local K={}k=k or 1;J=J==nil and"__MODULES_"..c.makeid(25)or J;local function l(m)local function M(n)local N=io.open(i..n,"r")or io.open(i..n..".lua","r")if not N then return("require\"%s\""):format(n)end;N:close()local o=I[n]or k;if not I[n]then I[n]=k;k=k+1 end;if H then K[H]=K[H]or{}table.insert(K[H],n)end;return J.."["..o.."]"end;m=m:gsub('require%s*%b""',function(n)local N=n:match('"(.+)"')return M(N)end)return m end;local L=l(g)for m,M in pairs(I)do if not j[m]then local n=D(m,i)if n then j[m]=n;local N=c.bundle(n,false,m,i,I,j,J,k)j[m]=N else print("WARNING: Failed to read module "..m)end end end;if h then local m=string.format([[
local _%s = {}
local %s = setmetatable({}, {
    __index = function(t, k)
        local mod = rawget(_%s, k)
        if mod == nil then
            error("Module not found: " .. tostring(k))
        end
        return mod
    end;
    __newindex = function(t, k, v)
        local b = rawget(_%s, k)
        if b == nil then
            return rawset(_%s, k, v)
        end
        if type(b) == "table" or type(b) == "userdata" then
            if type(v) == "function" then
                local mt = getmetatable(b)
                if mt then
                    mt.__call = function(self,...)
                        return v(...)
                    end
                else
                    setmetatable(b, {
                        __call = function(self,...)
                            return v(...)
                        end
                    })
                end
            elseif type(v) == "table" or type(v) == "userdata" then
                for i,_ in next, b do
                    b[i] = nil
                end
                for i,j in next, v do
                    b[i] = j
                end
                local mt = {}
                local _mt = getmetatable(v)
                if _mt then
                    for i,j in next, _mt do
                        mt[i] = j
                    end
                end
                mt.__index = function(self,k)
                    return v[k]
                end
                mt.__newindex = function(self,k,V)
                    v[k] = V
                end
            end
        end
        rawset(_%s, k, v)
    end
})
]],J,J,J,J,J,J)for M,n in pairs(I)do m=m..string.format("%s[%d] = {}\n",J,n)end;for M,n in pairs(I)do m=m..string.format([[
do
    local module = function()
        %s
    end
    %s[%d] = module()
end
]],j[M],J,n)end;L=m..L end;return L end;function c.makeid(g)local h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"local H="0123456789"local i=""local I=true;for j=1,g do local J=I and h or(h..H)local k=math.random(#J)i=i..J:sub(k,k)I=false end;return i end;function c.removeComments(g)g=g:gsub("%-%-.-\n","\n")g=g:gsub("%-%-%[%[.-%]%]","")return g end;function c.minifyLua(g)local h,H=B(g)if not h then error(H)return end;return b(H)end;function c.writeFile(g,h)local H=io.open(g,"w")if not H then return false end;H:write(h)H:close()return true end;function c.main(g,h)g=g or"main.lua"h=h or"bundled.min.lua"local H,i=D(g)if not H then print("ERROR: Cannot read "..g)return false end;local I=c.bundle(H,true,nil,C(i))local j=c.minifyLua(I)if c.writeFile(h,j)then print("Bundling and minification completed successfully.")return true else print("Failed to write "..h)return false end end;math.randomseed(os.time())local e={...}if#e<1 then error("Usage: bundle.lua [entrypoint] [?-o output]")end;local E=e[1]local f=""do local g={}for h in E:gmatch("([^.]+)")do table.insert(g,h)end;if#g>1 and g[#g]=="lua"then table.remove(g,#g)end;f=table.concat(g,".")end;local F=f..".min.lua"for g=2,#e-1 do if e[g]:lower()=="-o"then F=e[g+1]end end;c.main(E,F)