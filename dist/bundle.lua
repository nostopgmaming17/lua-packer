local e={}do local D=function()local h={new=function(H,i)local I={Parent=i,Locals={},Globals={},oldLocalNamesMap={},oldGlobalNamesMap={},Children={}}if i then table.insert(i.Children,I)end;return setmetatable(I,{__index=H})end,AddLocal=function(H,i)table.insert(H.Locals,i)end,AddGlobal=function(H,i)table.insert(H.Globals,i)end,CreateLocal=function(H,i)local I;I=H:GetLocal(i)if I then return I end;I={}I.Scope=H;I.Name=i;I.IsGlobal=false;I.CanRename=true;I.References=1;H:AddLocal(I)return I end,GetLocal=function(H,i)for I,j in pairs(H.Locals)do if j.Name==i then return j end end;if H.Parent then return H.Parent:GetLocal(i)end end,GetOldLocal=function(H,i)if H.oldLocalNamesMap[i]then return H.oldLocalNamesMap[i]end;return H:GetLocal(i)end,mapLocal=function(H,i,I)H.oldLocalNamesMap[i]=I end,GetOldGlobal=function(H,i)if H.oldGlobalNamesMap[i]then return H.oldGlobalNamesMap[i]end;return H:GetGlobal(i)end,mapGlobal=function(H,i,I)H.oldGlobalNamesMap[i]=I end,GetOldVariable=function(H,i)return H:GetOldLocal(i)or H:GetOldGlobal(i)end,RenameLocal=function(H,i,I)i=type(i)=='string'and i or i.Name;local j=false;local J=H:GetLocal(i)if J then J.Name=I;H:mapLocal(i,J)j=true end;if not j and H.Parent then H.Parent:RenameLocal(i,I)end end,RenameGlobal=function(H,i,I)i=type(i)=='string'and i or i.Name;local j=false;local J=H:GetGlobal(i)if J then J.Name=I;H:mapGlobal(i,J)j=true end;if not j and H.Parent then H.Parent:RenameGlobal(i,I)end end,RenameVariable=function(H,i,I)i=type(i)=='string'and i or i.Name;if H:GetLocal(i)then H:RenameLocal(i,I)else H:RenameGlobal(i,I)end end,GetAllVariables=function(H)local i=H:getVars(true)for I,j in pairs(H:getVars(false))do table.insert(i,j)end;return i end,getVars=function(H,i)local I={}if i then for j,J in pairs(H.Children)do for k,K in pairs(J:getVars(true))do table.insert(I,K)end end else for j,J in pairs(H.Locals)do table.insert(I,J)end;for j,J in pairs(H.Globals)do table.insert(I,J)end;if H.Parent then for j,J in pairs(H.Parent:getVars(false))do table.insert(I,J)end end end;return I end,CreateGlobal=function(H,i)local I;I=H:GetGlobal(i)if I then return I end;I={}I.Scope=H;I.Name=i;I.IsGlobal=true;I.CanRename=true;I.References=1;H:AddGlobal(I)return I end,GetGlobal=function(H,i)for I,j in pairs(H.Globals)do if j.Name==i then return j end end;if H.Parent then return H.Parent:GetGlobal(i)end end,GetVariable=function(H,i)return H:GetLocal(i)or H:GetGlobal(i)end,ObfuscateLocals=function(H,i,I)i=i or 7;local j="aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ_"local J="0123456789"local k=j..J;for K,l in pairs(H.Locals)do local L="a"local m={1}local M=0;while H:GetVariable(L)do local n=#m>1 and#k or#j;m[#m]=m[#m]+1;for N=1,#m-1 do if m[N+1]>n then m[N]=m[N]+1;m[N+1]=1 end end;if m[1]>n then m[1]=1;table.insert(m,1)end;L=""for N=1,#m do L=L..k:sub(m[N],m[N])end end;H:RenameLocal(l.Name,L)end end}return h end;e[5]=function()local h=D()e[5]=function()return h end;return h end end;do local D=function()local h=e[1]()local H=h.ParseLua;local i=e[3]()local I=i.lookupify;local j=I{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local J=I{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local k=I{'0','1','2','3','4','5','6','7','8','9'}local K=I{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local function l(L)local m,M;local n=0;local function N(O,p,P)P=P or' 'local q,Q=O:sub(-1,-1),p:sub(1,1)if J[q]or j[q]or q=='_'then if not(J[Q]or j[Q]or Q=='_'or k[Q])then return O..p elseif Q=='('then print("==============>>>",q,Q)return O..P..p else return O..P..p end elseif k[q]then if Q=='('then return O..p elseif K[Q]then return O..p else return O..P..p end elseif q==''then return O..p else if Q=='('then return O..P..p else return O..p end end end;M=function(O,p)local p=p or 0;local P=0;local q=false;local Q=""if O.AstType=='VarExpr'then if O.Variable then Q=Q..O.Variable.Name else Q=Q..O.Name end elseif O.AstType=='NumberExpr'then Q=Q..O.Value.Data elseif O.AstType=='StringExpr'then Q=Q..O.Value.Data elseif O.AstType=='BooleanExpr'then Q=Q..tostring(O.Value)elseif O.AstType=='NilExpr'then Q=N(Q,"nil")elseif O.AstType=='BinopExpr'then P=O.OperatorPrecedence;Q=N(Q,M(O.Lhs,P))Q=N(Q,O.Op)Q=N(Q,M(O.Rhs))if O.Op=='^'or O.Op=='..'then P=P-1 end;if P<p then q=false else q=true end elseif O.AstType=='UnopExpr'then Q=N(Q,O.Op)Q=N(Q,M(O.Rhs))elseif O.AstType=='DotsExpr'then Q=Q.."..."elseif O.AstType=='CallExpr'then Q=Q..M(O.Base)Q=Q.."("for r=1,#O.Arguments do Q=Q..M(O.Arguments[r])if r~=#O.Arguments then Q=Q..","end end;Q=Q..")"elseif O.AstType=='TableCallExpr'then Q=Q..M(O.Base)Q=Q..M(O.Arguments[1])elseif O.AstType=='StringCallExpr'then Q=Q..M(O.Base)Q=Q..O.Arguments[1].Data elseif O.AstType=='IndexExpr'then Q=Q..M(O.Base).."["..M(O.Index).."]"elseif O.AstType=='MemberExpr'then Q=Q..M(O.Base)..O.Indexer..O.Ident.Data elseif O.AstType=='Function'then O.Scope:ObfuscateVariables()Q=Q.."function("if#O.Arguments>0 then for r=1,#O.Arguments do Q=Q..O.Arguments[r].Name;if r~=#O.Arguments then Q=Q..","elseif O.VarArg then Q=Q..",..."end end elseif O.VarArg then Q=Q.."..."end;Q=Q..")"Q=N(Q,m(O.Body))Q=N(Q,"end")elseif O.AstType=='ConstructorExpr'then Q=Q.."{"for r=1,#O.EntryList do local R=O.EntryList[r]if R.Type=='Key'then Q=Q.."["..M(R.Key).."]="..M(R.Value)elseif R.Type=='Value'then Q=Q..M(R.Value)elseif R.Type=='KeyString'then Q=Q..R.Key.."="..M(R.Value)end;if r~=#O.EntryList then Q=Q..","end end;Q=Q.."}"elseif O.AstType=='Parentheses'then Q=Q.."("..M(O.Inner)..")"end;if not q then Q=string.rep('(',O.ParenCount or 0)..Q;Q=Q..string.rep(')',O.ParenCount or 0)end;n=n+#Q;return Q end;local o=function(O)local p=''if O.AstType=='AssignmentStatement'then for P=1,#O.Lhs do p=p..M(O.Lhs[P])if P~=#O.Lhs then p=p..","end end;if#O.Rhs>0 then p=p.."="for P=1,#O.Rhs do p=p..M(O.Rhs[P])if P~=#O.Rhs then p=p..","end end end elseif O.AstType=='SpecialAssignmentStatement'then p=p..M(O.Lhs)p=p..O.Operator;p=p..M(O.Rhs)elseif O.AstType=='CallStatement'then p=M(O.Expression)elseif O.AstType=='LocalStatement'then p=p.."local "for P=1,#O.LocalList do p=p..O.LocalList[P].Name;if P~=#O.LocalList then p=p..","end end;if#O.InitList>0 then p=p.."="for P=1,#O.InitList do p=p..M(O.InitList[P])if P~=#O.InitList then p=p..","end end end elseif O.AstType=='IfStatement'then p=N("if",M(O.Clauses[1].Condition))p=N(p,"then")p=N(p,m(O.Clauses[1].Body))for P=2,#O.Clauses do local q=O.Clauses[P]if q.Condition then p=N(p,"elseif")p=N(p,M(q.Condition))p=N(p,"then")else p=N(p,"else")end;p=N(p,m(q.Body))end;p=N(p,"end")elseif O.AstType=='WhileStatement'then p=N("while",M(O.Condition))p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='DoStatement'then p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='ReturnStatement'then p="return"for P=1,#O.Arguments do p=N(p,M(O.Arguments[P]))if P~=#O.Arguments then p=p..","end end elseif O.AstType=='ContinueStatement'then p="continue"elseif O.AstType=='BreakStatement'then p="break"elseif O.AstType=='RepeatStatement'then p="repeat"p=N(p,m(O.Body))p=N(p,"until")p=N(p,M(O.Condition))elseif O.AstType=='Function'then O.Scope:ObfuscateVariables()if O.IsLocal then p="local"end;p=N(p,"function ")if O.IsLocal then p=p..O.Name.Name else p=p..M(O.Name)end;p=p.."("if#O.Arguments>0 then for P=1,#O.Arguments do p=p..O.Arguments[P].Name;if P~=#O.Arguments then p=p..","elseif O.VarArg then p=p..",..."end end elseif O.VarArg then p=p.."..."end;p=p..")"p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='GenericForStatement'then O.Scope:ObfuscateVariables()p="for "for P=1,#O.VariableList do p=p..O.VariableList[P].Name;if P~=#O.VariableList then p=p..","end end;p=p.." in"for P=1,#O.Generators do p=N(p,M(O.Generators[P]))if P~=#O.Generators then p=N(p,',')end end;p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='NumericForStatement'then O.Scope:ObfuscateVariables()p="for "p=p..O.Variable.Name.."="p=p..M(O.Start)..","..M(O.End)if O.Step then p=p..","..M(O.Step)end;p=N(p,"do")p=N(p,m(O.Body))p=N(p,"end")elseif O.AstType=='LabelStatement'then p=getIndentation().."::"..O.Label.."::"elseif O.AstType=='GotoStatement'then p=getIndentation().."goto "..O.Label elseif O.AstType=='Comment'then elseif O.AstType=='Eof'then else print("Unknown AST Type: "..O.AstType)end;n=n+#p;return p end;m=function(O)local p=''O.Scope:ObfuscateVariables()for P,q in pairs(O.Body)do p=N(p,o(q),';')end;return p end;L.Scope:ObfuscateVariables()return m(L)end;return l end;e[2]=function()local h=D()e[2]=function()return h end;return h end end;do local D=function()if true then __STRICT=true;function global()end;return end;local h=getmetatable(_G)if h==nil then h={}setmetatable(_G,h)end;__STRICT=true;h.__declared={}h.__newindex=function(H,i,I)if __STRICT and not h.__declared[i]then local j=debug.getinfo(2,"S").what;if j~="main"and j~="C"then error("assign to undeclared variable '"..i.."'",2)end;h.__declared[i]=true end;rawset(H,i,I)end;h.__index=function(H,i)if not h.__declared[i]and debug.getinfo(2,"S").what~="C"then error("variable '"..i.."' is not declared",2)end;return rawget(H,i)end;function global(...)for H,i in ipairs{...}do h.__declared[i]=true end end end;e[4]=function()local h=D()e[4]=function()return h end;return h end end;do local D=function()local function h(J)for k,K in pairs(J)do J[K]=true end;return J end;local function H(J)local k=0;for K in pairs(J)do k=k+1 end;return k end;local function i(J,k)if J.Print then return J.Print()end;k=k or 0;local K=(H(J)>1)local l=string.rep('    ',k+1)local L="{".. (K and'\n'or'')for m,M in pairs(J)do if type(M)~='function'then L=L.. (K and l or'')if type(m)=='number'then elseif type(m)=='string'and m:match("^[A-Za-z_][A-Za-z0-9_]*$")then L=L..m.." = "elseif type(m)=='string'then L=L.."[\""..m.."\"] = "else L=L.."["..tostring(m).."] = "end;if type(M)=='string'then L=L.."\""..M.."\""elseif type(M)=='number'then L=L..M elseif type(M)=='table'then L=L..i(M,k+ (K and 1 or 0))else L=L..tostring(M)end;if next(J,m)then L=L..","end;if K then L=L..'\n'end end end;L=L.. (K and string.rep('    ',k)or'').."}"return L end;local function I(J)if J:match("\n")then local k={}for K in J:gmatch("[^\n]*")do table.insert(k,K)end;assert(#k>0)return k else return{J}end end;local function j(J,...)return print(string.format(J,...))end;return{PrintTable=i,CountTable=H,lookupify=h,splitLines=I,printf=j}end;e[3]=function()local h=D()e[3]=function()return h end;return h end end;do local D=function()e[4]()local h=e[3]()local H=h.lookupify;local i=H{' ','\n','\t','\r'}local I={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'"}local j=H{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local J=H{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local k=H{'0','1','2','3','4','5','6','7','8','9'}local K=H{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}local l=H{',','{','}','[',']','(',')',';','#'}local L=e[5]()local m=H{'and','continue','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'}local function M(N)local o={}local O,p=pcall(function()local r=1;local R=1;local s=1;local function S()local v=N:sub(r,r)if v=='\n'then s=1;R=R+1 else s=s+1 end;r=r+1;return v end;local function t(v)v=v or 0;return N:sub(r+v,r+v)end;local function T(v)local V=t()for w=1,#v do if V==v:sub(w,w)then return S()end end end;local function u(v)return error(">> :"..R..":"..s..": "..v,0)end;local function U()local v=r;if t()=='['then local V=0;local w=1;while t(V+1)=='='do V=V+1 end;if t(V+1)=='['then for y=0,V+1 do S()end;local W=r;while true do if t()==''then u("Expected `]"..string.rep('=',V).."]` near <eof>.",3)end;local y=true;if t()==']'then for Y=1,V do if t(Y)~='='then y=false end end;if t(V+1)~=']'then y=false end else if t()=='['then local Y=true;for z=1,V do if t(z)~='='then Y=false;break end end;if t(V+1)=='['and Y then w=w+1;for z=1,(V+2)do S()end end end;y=false end;if y then w=w-1;if w==0 then break else for Y=1,V+2 do S()end end else S()end end;local x=N:sub(W,r-1)for y=0,V+1 do S()end;local X=N:sub(v,r-1)return x,X else return nil end else return nil end end;while true do local v={}local V=''local w=false;while true do local z=t()if z=='#'and t(1)=='!'and R==1 then S()S()V="#!"while t()~='\n'and t()~=''do V=V..S()end;local Z={Type='Comment',CommentType='Shebang',Data=V,Line=R,Char=s}Z.Print=function()return"<".. (Z.Type..string.rep(' ',7-#Z.Type)).."  ".. (Z.Data or'').." >"end;V=""table.insert(v,Z)end;if z==' 'or z=='\t'then local Z=S()table.insert(v,{Type='Whitespace',Line=R,Char=s,Data=Z})elseif z=='\n'or z=='\r'then local Z=S()if V~=""then local _={Type='Comment',CommentType=w and'LongComment'or'Comment',Data=V,Line=R,Char=s}_.Print=function()return"<".. (_.Type..string.rep(' ',7-#_.Type)).."  ".. (_.Data or'').." >"end;table.insert(v,_)V=""end;table.insert(v,{Type='Whitespace',Line=R,Char=s,Data=Z})elseif z=='-'and t(1)=='-'then S()S()V=V..'--'local Z,_=U()if _ then V=V.._;w=true else while t()~='\n'and t()~=''do V=V..S()end end else break end end;if V~=""then local z={Type='Comment',CommentType=w and'LongComment'or'Comment',Data=V,Line=R,Char=s}z.Print=function()return"<".. (z.Type..string.rep(' ',7-#z.Type)).."  ".. (z.Data or'').." >"end;table.insert(v,z)end;local W=R;local x=s;local X=":"..R..":"..s..":> "local y=t()local Y=nil;if y==''then Y={Type='Eof'}elseif J[y]or j[y]or y=='_'then local z=r;repeat S()y=t()until not(J[y]or j[y]or k[y]or y=='_')local Z=N:sub(z,r-1)if m[Z]then Y={Type='Keyword',Data=Z}else Y={Type='Ident',Data=Z}end elseif k[y]or(t()=='.'and k[t(1)])then local z=r;if y=='0'and t(1)=='x'then S()S()while K[t()]do S()end;if T('Pp')then T('+-')while k[t()]do S()end end else while k[t()]do S()end;if T('.')then while k[t()]do S()end end;if T('Ee')then T('+-')while k[t()]do S()end end end;Y={Type='Number',Data=N:sub(z,r-1)}elseif y=='\''or y=='\"'then local z=r;local Z=S()local _=r;while true do local y=S()if y=='\\'then S()elseif y==Z then break elseif y==''then u("Unfinished string near <eof>")end end;local aa=N:sub(_,r-2)local aA=N:sub(z,r-1)Y={Type='String',Data=aA,Constant=aa}elseif y=='['then local z,Z=U()if Z then Y={Type='String',Data=Z,Constant=z}else S()Y={Type='Symbol',Data='['}end elseif T('>=<')then if T('=')then Y={Type='Symbol',Data=y..'='}else Y={Type='Symbol',Data=y}end elseif T('~')then if T('=')then Y={Type='Symbol',Data='~='}else u("Unexpected symbol `~` in source.",2)end elseif T('.')then if T('.')then if T('.')then Y={Type='Symbol',Data='...'}else Y={Type='Symbol',Data='..'}end else Y={Type='Symbol',Data='.'}end elseif T(':')then if T(':')then Y={Type='Symbol',Data='::'}else Y={Type='Symbol',Data=':'}end elseif y=='+'or y=='-'or y=='*'or y=='/'or y=='%'or y=='^'then local z=S()if t()=='='then S()Y={Type='Symbol',Data=z..'='}else Y={Type='Symbol',Data=z}end elseif l[y]then S()Y={Type='Symbol',Data=y}else local z,Z=U()if z then Y={Type='String',Data=Z,Constant=z}else u("Unexpected Symbol `"..y.."` in source.",2)end end;Y.LeadingWhite=v;Y.Line=W;Y.Char=x;Y.Print=function()return"<".. (Y.Type..string.rep(' ',7-#Y.Type)).."  ".. (Y.Data or'').." >"end;o[#o+1]=Y;if Y.Type=='Eof'then break end end end)if not O then return false,p end;local P={}local q={}local Q=1;function P:getp()return Q end;function P:setp(r)Q=r end;function P:getTokenList()return o end;function P:Peek(r)r=r or 0;return o[math.min(#o,Q+r)]end;function P:Get(r)local R=o[Q]Q=math.min(Q+1,#o)if r then table.insert(r,R)end;return R end;function P:Is(r)return P:Peek().Type==r end;function P:Save()q[#q+1]=Q end;function P:Commit()q[#q]=nil end;function P:Restore()Q=q[#q]q[#q]=nil end;function P:ConsumeSymbol(r,R)local s=self:Peek()if s.Type=='Symbol'then if r then if s.Data==r then self:Get(R)return true else return nil end else self:Get(R)return s end else return nil end end;function P:ConsumeKeyword(r,R)local s=self:Peek()if s.Type=='Keyword'and s.Data==r then self:Get(R)return true else return nil end end;function P:IsKeyword(r)local R=P:Peek()return R.Type=='Keyword'and R.Data==r end;function P:IsSymbol(r)local R=P:Peek()return R.Type=='Symbol'and R.Data==r end;function P:IsEof()return P:Peek().Type=='Eof'end;return true,P end;local function n(N)local R,s;if type(N)~='table'then R,s=M(N)else R,s=true,N end;if not R then return false,s end;local function S(r)local z=">> :"..s:Peek().Line..":"..s:Peek().Char..": "..r.."\n"local Z=0;if type(N)=='string'then for _ in N:gmatch("[^\n]*\n?")do if _:sub(-1,-1)=='\n'then _=_:sub(1,-2)end;Z=Z+1;if Z==s:Peek().Line then z=z..">> `".._:gsub('\t','    ').."`\n"for aa=1,s:Peek().Char do local aA=_:sub(aa,aa)if aA=='\t'then z=z..'    'else z=z..' 'end end;z=z.."   ^^^^"break end end end;return z end;local t=0;local T={'_','a','b','c','d'}local function u(r)local z=L:new(r)z.RenameVars=z.ObfuscateLocals;z.ObfuscateVariables=z.ObfuscateLocals;z.Print=function()return"<Scope>"end;return z end;local U;local v;local V,w,W,x;local function X(r,z)local Z=u(r)if not s:ConsumeSymbol('(',z)then return false,S("`(` expected.")end;local _={}local aa=false;while not s:ConsumeSymbol(')',z)do if s:Is('Ident')then local aB=Z:CreateLocal(s:Get(z).Data)_[#_+1]=aB;if not s:ConsumeSymbol(',',z)then if s:ConsumeSymbol(')',z)then break else return false,S("`)` expected.")end end elseif s:ConsumeSymbol('...',z)then aa=true;if not s:ConsumeSymbol(')',z)then return false,S("`...` must be the last argument of a function.")end;break else return false,S("Argument name or `...` expected")end end;local R,aA=v(Z)if not R then return false,aA end;if not s:ConsumeKeyword('end',z)then return false,S("`end` expected after function body")end;local ab={}ab.AstType='Function'ab.Scope=Z;ab.Arguments=_;ab.Body=aA;ab.VarArg=aa;ab.Tokens=z;return true,ab end;function W(r)local z={}if s:ConsumeSymbol('(',z)then local R,Z=U(r)if not R then return false,Z end;if not s:ConsumeSymbol(')',z)then return false,S("`)` Expected.")end;if false then Z.ParenCount=(Z.ParenCount or 0)+1;return true,Z else local _={}_.AstType='Parentheses'_.Inner=Z;_.Tokens=z;return true,_ end elseif s:Is('Ident')then local Z=s:Get(z)local _=r:GetLocal(Z.Data)if not _ then _=r:GetGlobal(Z.Data)if not _ then _=r:CreateGlobal(Z.Data)else _.References=_.References+1 end else _.References=_.References+1 end;local aa={}aa.AstType='VarExpr'aa.Name=Z.Data;aa.Variable=_;aa.Tokens=z;return true,aa else return false,S("primary expression expected")end end;function x(r,z)local R,Z=W(r)if not R then return false,Z end;while true do local _={}if s:IsSymbol('.')or s:IsSymbol(':')then local aa=s:Get(_).Data;if not s:Is('Ident')then return false,S("<Ident> expected.")end;local aA=s:Get(_)local ab={}ab.AstType='MemberExpr'ab.Base=Z;ab.Indexer=aa;ab.Ident=aA;ab.Tokens=_;Z=ab elseif not z and s:ConsumeSymbol('[',_)then local R,aa=U(r)if not R then return false,aa end;if not s:ConsumeSymbol(']',_)then return false,S("`]` expected.")end;local aA={}aA.AstType='IndexExpr'aA.Base=Z;aA.Index=aa;aA.Tokens=_;Z=aA elseif not z and s:ConsumeSymbol('(',_)then local aa={}while not s:ConsumeSymbol(')',_)do local R,ab=U(r)if not R then return false,ab end;aa[#aa+1]=ab;if not s:ConsumeSymbol(',',_)then if s:ConsumeSymbol(')',_)then break else return false,S("`)` Expected.")end end end;local aA={}aA.AstType='CallExpr'aA.Base=Z;aA.Arguments=aa;aA.Tokens=_;Z=aA elseif not z and s:Is('String')then local aa={}aa.AstType='StringCallExpr'aa.Base=Z;aa.Arguments={s:Get(_)}aa.Tokens=_;Z=aa elseif not z and s:IsSymbol('{')then local R,aa=V(r)if not R then return false,aa end;local aA={}aA.AstType='TableCallExpr'aA.Base=Z;aA.Arguments={aa}aA.Tokens=_;Z=aA else break end end;return true,Z end;function V(r)local z={}if s:Is('Number')then local Z={}Z.AstType='NumberExpr'Z.Value=s:Get(z)Z.Tokens=z;return true,Z elseif s:Is('String')then local Z={}Z.AstType='StringExpr'Z.Value=s:Get(z)Z.Tokens=z;return true,Z elseif s:ConsumeKeyword('nil',z)then local Z={}Z.AstType='NilExpr'Z.Tokens=z;return true,Z elseif s:IsKeyword('false')or s:IsKeyword('true')then local Z={}Z.AstType='BooleanExpr'Z.Value=(s:Get(z).Data=='true')Z.Tokens=z;return true,Z elseif s:ConsumeSymbol('...',z)then local Z={}Z.AstType='DotsExpr'Z.Tokens=z;return true,Z elseif s:ConsumeSymbol('{',z)then local Z={}Z.AstType='ConstructorExpr'Z.EntryList={}while true do if s:IsSymbol('[',z)then s:Get(z)local R,_=U(r)if not R then return false,S("Key Expression Expected")end;if not s:ConsumeSymbol(']',z)then return false,S("`]` Expected")end;if not s:ConsumeSymbol('=',z)then return false,S("`=` Expected")end;local R,aa=U(r)if not R then return false,S("Value Expression Expected")end;Z.EntryList[#Z.EntryList+1]={Type='Key',Key=_,Value=aa}elseif s:Is('Ident')then local _=s:Peek(1)if _.Type=='Symbol'and _.Data=='='then local aa=s:Get(z)if not s:ConsumeSymbol('=',z)then return false,S("`=` Expected")end;local R,aA=U(r)if not R then return false,S("Value Expression Expected")end;Z.EntryList[#Z.EntryList+1]={Type='KeyString',Key=aa.Data,Value=aA}else local R,aa=U(r)if not R then return false,S("Value Exected")end;Z.EntryList[#Z.EntryList+1]={Type='Value',Value=aa}end elseif s:ConsumeSymbol('}',z)then break else local R,_=U(r)Z.EntryList[#Z.EntryList+1]={Type='Value',Value=_}if not R then return false,S("Value Expected")end end;if s:ConsumeSymbol(';',z)or s:ConsumeSymbol(',',z)then elseif s:ConsumeSymbol('}',z)then break else return false,S("`}` or table entry Expected")end end;Z.Tokens=z;return true,Z elseif s:ConsumeKeyword('function',z)then local R,Z=X(r,z)if not R then return false,Z end;Z.IsLocal=true;return true,Z else return x(r)end end;local y=H{'-','not','#'}local Y=H{'+=','-=','*=','/=','%=','^='}local o=8;local O={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}function w(r,z)local R,Z;if y[s:Peek().Data]then local _={}local aa=s:Get(_).Data;R,Z=w(r,o)if not R then return false,Z end;local aA={}aA.AstType='UnopExpr'aA.Rhs=Z;aA.Op=aa;aA.OperatorPrecedence=o;aA.Tokens=_;Z=aA else R,Z=V(r)if not R then return false,Z end end;while true do local _=O[s:Peek().Data]if _ and _[1]>z then local aa={}local aA=s:Get(aa).Data;local R,ab=w(r,_[2])if not R then return false,ab end;local aB={}aB.AstType='BinopExpr'aB.Lhs=Z;aB.Op=aA;aB.OperatorPrecedence=_[1]aB.Rhs=ab;aB.Tokens=aa;Z=aB else break end end;return true,Z end;U=function(r)return w(r,0)end;local function p(r)local z=nil;local Z={}if s:ConsumeKeyword('if',Z)then local _={}_.AstType='IfStatement'_.Clauses={}repeat local R,aa=U(r)if not R then return false,aa end;if not s:ConsumeKeyword('then',Z)then return false,S("`then` expected.")end;local R,aA=v(r)if not R then return false,aA end;_.Clauses[#_.Clauses+1]={Condition=aa,Body=aA}until not s:ConsumeKeyword('elseif',Z)if s:ConsumeKeyword('else',Z)then local R,aa=v(r)if not R then return false,aa end;_.Clauses[#_.Clauses+1]={Body=aa}end;if not s:ConsumeKeyword('end',Z)then return false,S("`end` expected.")end;_.Tokens=Z;z=_ elseif s:ConsumeKeyword('while',Z)then local _={}_.AstType='WhileStatement'local R,aa=U(r)if not R then return false,aa end;if not s:ConsumeKeyword('do',Z)then return false,S("`do` expected.")end;local R,aA=v(r)if not R then return false,aA end;if not s:ConsumeKeyword('end',Z)then return false,S("`end` expected.")end;_.Condition=aa;_.Body=aA;_.Tokens=Z;z=_ elseif s:ConsumeKeyword('do',Z)then local R,_=v(r)if not R then return false,_ end;if not s:ConsumeKeyword('end',Z)then return false,S("`end` expected.")end;local aa={}aa.AstType='DoStatement'aa.Body=_;aa.Tokens=Z;z=aa elseif s:ConsumeKeyword('for',Z)then if not s:Is('Ident')then return false,S("<ident> expected.")end;local _=s:Get(Z)if s:ConsumeSymbol('=',Z)then local aa=u(r)local aA=aa:CreateLocal(_.Data)local R,ab=U(r)if not R then return false,ab end;if not s:ConsumeSymbol(',',Z)then return false,S("`,` Expected")end;local R,aB=U(r)if not R then return false,aB end;local R,ac;if s:ConsumeSymbol(',',Z)then R,ac=U(r)if not R then return false,ac end end;if not s:ConsumeKeyword('do',Z)then return false,S("`do` expected")end;local R,aC=v(aa)if not R then return false,aC end;if not s:ConsumeKeyword('end',Z)then return false,S("`end` expected")end;local ad={}ad.AstType='NumericForStatement'ad.Scope=aa;ad.Variable=aA;ad.Start=ab;ad.End=aB;ad.Step=ac;ad.Body=aC;ad.Tokens=Z;z=ad else local aa=u(r)local aA={aa:CreateLocal(_.Data)}while s:ConsumeSymbol(',',Z)do if not s:Is('Ident')then return false,S("for variable expected.")end;aA[#aA+1]=aa:CreateLocal(s:Get(Z).Data)end;if not s:ConsumeKeyword('in',Z)then return false,S("`in` expected.")end;local ab={}local R,aB=U(r)if not R then return false,aB end;ab[#ab+1]=aB;while s:ConsumeSymbol(',',Z)do local R,ad=U(r)if not R then return false,ad end;ab[#ab+1]=ad end;if not s:ConsumeKeyword('do',Z)then return false,S("`do` expected.")end;local R,ac=v(aa)if not R then return false,ac end;if not s:ConsumeKeyword('end',Z)then return false,S("`end` expected.")end;local aC={}aC.AstType='GenericForStatement'aC.Scope=aa;aC.VariableList=aA;aC.Generators=ab;aC.Body=ac;aC.Tokens=Z;z=aC end elseif s:ConsumeKeyword('repeat',Z)then local R,_=v(r)if not R then return false,_ end;if not s:ConsumeKeyword('until',Z)then return false,S("`until` expected.")end;local R,aa=U(_.Scope)if not R then return false,aa end;local aA={}aA.AstType='RepeatStatement'aA.Condition=aa;aA.Body=_;aA.Tokens=Z;z=aA elseif s:ConsumeKeyword('function',Z)then if not s:Is('Ident')then return false,S("Function name expected")end;local R,_=x(r,true)if not R then return false,_ end;local R,aa=X(r,Z)if not R then return false,aa end;aa.IsLocal=false;aa.Name=_;z=aa elseif s:ConsumeKeyword('local',Z)then if s:Is('Ident')then local _={s:Get(Z).Data}while s:ConsumeSymbol(',',Z)do if not s:Is('Ident')then return false,S("local var name expected")end;_[#_+1]=s:Get(Z).Data end;local aa={}if s:ConsumeSymbol('=',Z)then repeat local R,ab=U(r)if not R then return false,ab end;aa[#aa+1]=ab until not s:ConsumeSymbol(',',Z)end;for ab,aB in pairs(_)do _[ab]=r:CreateLocal(aB)end;local aA={}aA.AstType='LocalStatement'aA.LocalList=_;aA.InitList=aa;aA.Tokens=Z;z=aA elseif s:ConsumeKeyword('function',Z)then if not s:Is('Ident')then return false,S("Function name expected")end;local _=s:Get(Z).Data;local aa=r:CreateLocal(_)local R,aA=X(r,Z)if not R then return false,aA end;aA.Name=aa;aA.IsLocal=true;z=aA else return false,S("local var or function def expected")end elseif s:ConsumeSymbol('::',Z)then if not s:Is('Ident')then return false,S('Label name expected')end;local _=s:Get(Z).Data;if not s:ConsumeSymbol('::',Z)then return false,S("`::` expected")end;local aa={}aa.AstType='LabelStatement'aa.Label=_;aa.Tokens=Z;z=aa elseif s:ConsumeKeyword('return',Z)then local _={}if not s:IsKeyword('end')then local R,aA=U(r)if R then _[1]=aA;while s:ConsumeSymbol(',',Z)do local R,ab=U(r)if not R then return false,ab end;_[#_+1]=ab end end end;local aa={}aa.AstType='ReturnStatement'aa.Arguments=_;aa.Tokens=Z;z=aa elseif s:ConsumeKeyword('continue',Z)then local _={}_.AstType='ContinueStatement'_.Tokens=Z;z=_ elseif s:ConsumeKeyword('break',Z)then local _={}_.AstType='BreakStatement'_.Tokens=Z;z=_ elseif s:ConsumeKeyword('goto',Z)then if not s:Is('Ident')then return false,S("Label expected")end;local _=s:Get(Z).Data;local aa={}aa.AstType='GotoStatement'aa.Label=_;aa.Tokens=Z;z=aa else local R,_=x(r)if not R then return false,_ end;local aa=s:Peek()if Y[aa.Data]then local aA=s:Get(Z).Data;if(_.ParenCount or 0)>0 then return false,S("Cannot assign to a parenthesized expression.")end;local ab,aB=U(r)if not ab then return false,aB end;local ac={}ac.AstType='SpecialAssignmentStatement'ac.Lhs=_;ac.Operator=aA;ac.Rhs=aB;ac.Tokens=Z;z=ac elseif s:IsSymbol(',')or s:IsSymbol('=')then if(_.ParenCount or 0)>0 then return false,S("Can not assign to parenthesized expression, is not an lvalue")end;local aA={_}while s:ConsumeSymbol(',',Z)do local R,aC=x(r)if not R then return false,aC end;aA[#aA+1]=aC end;if not s:ConsumeSymbol('=',Z)then return false,S("`=` Expected.")end;local ab={}local R,aB=U(r)if not R then return false,aB end;ab[1]=aB;while s:ConsumeSymbol(',',Z)do local R,aC=U(r)if not R then return false,aC end;ab[#ab+1]=aC end;local ac={}ac.AstType='AssignmentStatement'ac.Lhs=aA;ac.Rhs=ab;ac.Tokens=Z;z=ac elseif _.AstType=='CallExpr'or _.AstType=='TableCallExpr'or _.AstType=='StringCallExpr'then local aA={}aA.AstType='CallStatement'aA.Expression=_;aA.Tokens=Z;z=aA else return false,S("Assignment Statement Expected")end end;if s:IsSymbol(';')then z.Semicolon=s:Get(z.Tokens)end;return true,z end;local P=H{'end','else','elseif','until'}v=function(r)local z={}z.Scope=u(r)z.AstType='Statlist'z.Body={}z.Tokens={}while not P[s:Peek().Data]and not s:IsEof()do local R,Z=p(z.Scope)if not R then return false,Z end;z.Body[#z.Body+1]=Z end;if s:IsEof()then local Z={}Z.AstType='Eof'Z.Tokens={s:Get()}z.Body[#z.Body+1]=Z end;return true,z end;local function q()local r=u()return v(r)end;local R,Q=q()return R,Q end;return{LexLua=M,ParseLua=n}end;e[1]=function()local h=D()e[1]=function()return h end;return h end end;local E=e[1]()local G=e[2]()local f=E.ParseLua;local F={}local function g(D)return D:match("(.*/)")or"./"end;local function a(D)D=D:gsub("\\","/")D=D:gsub("//","/")local H={}for h in D:gmatch("[^/]+")do if h==".."then table.remove(H)elseif h~="."then table.insert(H,h)end end;return table.concat(H,"/")end;local function A(D,H)H=H and(H:match("/$")and H or H.."/")or""local h={D,H..D,H..D..".lua",H..D..".luau"}for i,I in ipairs(h)do local j=io.open(I,"r")if j then local k=j:read("*all")j:close()return k,I end end;return nil end;function F.bundle(D,k,K,l,h,H,i,I,j)for M,N in next,j do D=D:gsub(M,function()return N end)end;D=F.minifyLua(D)k=k or k==nil;K=K or nil;h=h or{}H=H or{}local J={}I=I or 1;i=i==nil and"__MODULES_"..F.makeid(25)or i;local function L(M)local function N(n)local p;local P,q=pcall(function()p=io.open(l..n,"r")or io.open(l..n..".lua","r")or io.open(l..n..".luau","r")end)if not P or not p then return("require\"%s\""):format(n)end;p:close()local o=h[n]or I;if not h[n]then h[n]=I;I=I+1 end;if K then J[K]=J[K]or{}table.insert(J[K],n)end;return i.."["..o.."]()"end;M=M:gsub('require%s*[%(%s]*([%\'"%[])(.-)%1[%)%s]*',function(n,O)return N(O)end)return M end;local m=L(D)for M,N in pairs(h)do if not H[M]then local n=A(M,l)if n then H[M]=n;local O=F.bundle(n,false,M,l,h,H,i,I,j)H[M]=O else print("WARNING: Failed to read module "..M)end end end;if k then local M=string.format([[
local %s = {}
]],i)for n,N in pairs(h)do M=M..string.format([[
do
    local module = function()
        %s
    end
    %s[%d] = function()
        local ret = module()
        %s[%d] = function() return ret end
        return ret
    end
end
]],H[n],i,N,i,N)end;m=M..m end;return m end;function F.makeid(D)local i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"local I="0123456789"local j=""local h=true;for H=1,D do local J=h and i or(i..I)local k=math.random(#J)j=j..J:sub(k,k)h=false end;return j end;function F.removeComments(D)D=D:gsub("%-%-.-\n","\n")D=D:gsub("%-%-%[%[.-%]%]","")return D end;function F.minifyLua(D)local h,H=f(D)if not h then error(H)return end;return G(H)end;function F.writeFile(D,H)local h=io.open(D,"w")if not h then return false end;h:write(H)h:close()return true end;function F.main(D,h,H)D=D or"main.lua"h=h or"bundled.min.lua"local j,k=A(D)if not j then print("ERROR: Cannot read "..D)return false end;j=F.minifyLua(j)local J=F.bundle(j,true,nil,g(k),nil,nil,nil,nil,H)local i=F.minifyLua(J)if F.writeFile(h,i)then print("Bundling and minification completed successfully.")return true else print("Failed to write "..h)return false end end;math.randomseed(os.time())local b={...}if#b<1 then error("Usage: bundle.lua [entrypoint] [?-o output]")end;local B=b[1]local c=""do local D={}for H in B:gmatch("([^.]+)")do table.insert(D,H)end;if#D>1 and D[#D]=="lua"then table.remove(D,#D)end;c=table.concat(D,".")end;local C=c..".min.lua"local d={}for D=2,#b-1 do if b[D]:lower()=="-o"then C=b[D+1]D=D+1 elseif b[D]:lower()=="-d"then local h,H=b[D+1]:match("(%w+)%s*=%s*(.-)%s*$")if type(h)=="string"and type(H)=="string"then d[h]=H end end end;F.main(B,C,d)