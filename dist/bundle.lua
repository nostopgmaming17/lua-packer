local E={}do local e=function()local G={new=function(h,H)local i={Parent=H,Locals={},Globals={},oldLocalNamesMap={},oldGlobalNamesMap={},Children={}}if H then table.insert(H.Children,i)end;return setmetatable(i,{__index=h})end,AddLocal=function(h,H)table.insert(h.Locals,H)end,AddGlobal=function(h,H)table.insert(h.Globals,H)end,CreateLocal=function(h,H)local i;i=h:GetLocal(H)if i then return i end;i={}i.Scope=h;i.Name=H;i.IsGlobal=false;i.CanRename=true;i.References=1;h:AddLocal(i)return i end,GetLocal=function(h,H)for i,I in pairs(h.Locals)do if I.Name==H then return I end end;if h.Parent then return h.Parent:GetLocal(H)end end,GetOldLocal=function(h,H)if h.oldLocalNamesMap[H]then return h.oldLocalNamesMap[H]end;return h:GetLocal(H)end,mapLocal=function(h,H,i)h.oldLocalNamesMap[H]=i end,GetOldGlobal=function(h,H)if h.oldGlobalNamesMap[H]then return h.oldGlobalNamesMap[H]end;return h:GetGlobal(H)end,mapGlobal=function(h,H,i)h.oldGlobalNamesMap[H]=i end,GetOldVariable=function(h,H)return h:GetOldLocal(H)or h:GetOldGlobal(H)end,RenameLocal=function(h,H,i)H=type(H)=='string'and H or H.Name;local I=false;local j=h:GetLocal(H)if j then j.Name=i;h:mapLocal(H,j)I=true end;if not I and h.Parent then h.Parent:RenameLocal(H,i)end end,RenameGlobal=function(h,H,i)H=type(H)=='string'and H or H.Name;local I=false;local j=h:GetGlobal(H)if j then j.Name=i;h:mapGlobal(H,j)I=true end;if not I and h.Parent then h.Parent:RenameGlobal(H,i)end end,RenameVariable=function(h,H,i)H=type(H)=='string'and H or H.Name;if h:GetLocal(H)then h:RenameLocal(H,i)else h:RenameGlobal(H,i)end end,GetAllVariables=function(h)local H=h:getVars(true)for i,I in pairs(h:getVars(false))do table.insert(H,I)end;return H end,getVars=function(h,H)local i={}if H then for I,j in pairs(h.Children)do for J,k in pairs(j:getVars(true))do table.insert(i,k)end end else for I,j in pairs(h.Locals)do table.insert(i,j)end;for I,j in pairs(h.Globals)do table.insert(i,j)end;if h.Parent then for I,j in pairs(h.Parent:getVars(false))do table.insert(i,j)end end end;return i end,CreateGlobal=function(h,H)local i;i=h:GetGlobal(H)if i then return i end;i={}i.Scope=h;i.Name=H;i.IsGlobal=true;i.CanRename=true;i.References=1;h:AddGlobal(i)return i end,GetGlobal=function(h,H)for i,I in pairs(h.Globals)do if I.Name==H then return I end end;if h.Parent then return h.Parent:GetGlobal(H)end end,GetVariable=function(h,H)return h:GetLocal(H)or h:GetGlobal(H)end,ObfuscateLocals=function(h,H,i)H=H or 7;local I="aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ_"local j="0123456789"local J=I..j;for k,K in pairs(h.Locals)do local l="a"local L={1}local m=0;while h:GetVariable(l)do local M=#L>1 and#J or#I;L[#L]=L[#L]+1;for n=1,#L-1 do if L[n+1]>M then L[n]=L[n]+1;L[n+1]=1 end end;if L[1]>M then L[1]=1;table.insert(L,1)end;l=""for n=1,#L do l=l..J:sub(L[n],L[n])end end;h:RenameLocal(K.Name,l)end end}return G end;E[5]=function()local G=e()E[5]=function()return G end;return G end end;do local e=function()local G=E[1]()local h=G.ParseLua;local H=E[3]()local i=H.lookupify;local I=i{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local j=i{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local J=i{'0','1','2','3','4','5','6','7','8','9'}local k=i{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local function K(l)local L,m;local M=0;local function n(o,O,p)p=p or' 'local P,q=o:sub(-1,-1),O:sub(1,1)if j[P]or I[P]or P=='_'then if not(j[q]or I[q]or q=='_'or J[q])then return o..O elseif q=='('then print("==============>>>",P,q)return o..p..O else return o..p..O end elseif J[P]then if q=='('then return o..O elseif k[q]then return o..O else return o..p..O end elseif P==''then return o..O else if q=='('then return o..p..O else return o..O end end end;m=function(o,O)local O=O or 0;local p=0;local P=false;local q=""if o.AstType=='VarExpr'then if o.Variable then q=q..o.Variable.Name else q=q..o.Name end elseif o.AstType=='NumberExpr'then q=q..o.Value.Data elseif o.AstType=='StringExpr'then q=q..o.Value.Data elseif o.AstType=='BooleanExpr'then q=q..tostring(o.Value)elseif o.AstType=='NilExpr'then q=n(q,"nil")elseif o.AstType=='BinopExpr'then p=o.OperatorPrecedence;q=n(q,m(o.Lhs,p))q=n(q,o.Op)q=n(q,m(o.Rhs))if o.Op=='^'or o.Op=='..'then p=p-1 end;if p<O then P=false else P=true end elseif o.AstType=='UnopExpr'then q=n(q,o.Op)q=n(q,m(o.Rhs))elseif o.AstType=='DotsExpr'then q=q.."..."elseif o.AstType=='CallExpr'then q=q..m(o.Base)q=q.."("for Q=1,#o.Arguments do q=q..m(o.Arguments[Q])if Q~=#o.Arguments then q=q..","end end;q=q..")"elseif o.AstType=='TableCallExpr'then q=q..m(o.Base)q=q..m(o.Arguments[1])elseif o.AstType=='StringCallExpr'then q=q..m(o.Base)q=q..o.Arguments[1].Data elseif o.AstType=='IndexExpr'then q=q..m(o.Base).."["..m(o.Index).."]"elseif o.AstType=='MemberExpr'then q=q..m(o.Base)..o.Indexer..o.Ident.Data elseif o.AstType=='Function'then o.Scope:ObfuscateVariables()q=q.."function("if#o.Arguments>0 then for Q=1,#o.Arguments do q=q..o.Arguments[Q].Name;if Q~=#o.Arguments then q=q..","elseif o.VarArg then q=q..",..."end end elseif o.VarArg then q=q.."..."end;q=q..")"q=n(q,L(o.Body))q=n(q,"end")elseif o.AstType=='ConstructorExpr'then q=q.."{"for Q=1,#o.EntryList do local r=o.EntryList[Q]if r.Type=='Key'then q=q.."["..m(r.Key).."]="..m(r.Value)elseif r.Type=='Value'then q=q..m(r.Value)elseif r.Type=='KeyString'then q=q..r.Key.."="..m(r.Value)end;if Q~=#o.EntryList then q=q..","end end;q=q.."}"elseif o.AstType=='Parentheses'then q=q.."("..m(o.Inner)..")"end;if not P then q=string.rep('(',o.ParenCount or 0)..q;q=q..string.rep(')',o.ParenCount or 0)end;M=M+#q;return q end;local N=function(o)local O=''if o.AstType=='AssignmentStatement'then for p=1,#o.Lhs do O=O..m(o.Lhs[p])if p~=#o.Lhs then O=O..","end end;if#o.Rhs>0 then O=O.."="for p=1,#o.Rhs do O=O..m(o.Rhs[p])if p~=#o.Rhs then O=O..","end end end elseif o.AstType=='CallStatement'then O=m(o.Expression)elseif o.AstType=='LocalStatement'then O=O.."local "for p=1,#o.LocalList do O=O..o.LocalList[p].Name;if p~=#o.LocalList then O=O..","end end;if#o.InitList>0 then O=O.."="for p=1,#o.InitList do O=O..m(o.InitList[p])if p~=#o.InitList then O=O..","end end end elseif o.AstType=='IfStatement'then O=n("if",m(o.Clauses[1].Condition))O=n(O,"then")O=n(O,L(o.Clauses[1].Body))for p=2,#o.Clauses do local P=o.Clauses[p]if P.Condition then O=n(O,"elseif")O=n(O,m(P.Condition))O=n(O,"then")else O=n(O,"else")end;O=n(O,L(P.Body))end;O=n(O,"end")elseif o.AstType=='WhileStatement'then O=n("while",m(o.Condition))O=n(O,"do")O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='DoStatement'then O=n(O,"do")O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='ReturnStatement'then O="return"for p=1,#o.Arguments do O=n(O,m(o.Arguments[p]))if p~=#o.Arguments then O=O..","end end elseif o.AstType=='BreakStatement'then O="break"elseif o.AstType=='RepeatStatement'then O="repeat"O=n(O,L(o.Body))O=n(O,"until")O=n(O,m(o.Condition))elseif o.AstType=='Function'then o.Scope:ObfuscateVariables()if o.IsLocal then O="local"end;O=n(O,"function ")if o.IsLocal then O=O..o.Name.Name else O=O..m(o.Name)end;O=O.."("if#o.Arguments>0 then for p=1,#o.Arguments do O=O..o.Arguments[p].Name;if p~=#o.Arguments then O=O..","elseif o.VarArg then O=O..",..."end end elseif o.VarArg then O=O.."..."end;O=O..")"O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='GenericForStatement'then o.Scope:ObfuscateVariables()O="for "for p=1,#o.VariableList do O=O..o.VariableList[p].Name;if p~=#o.VariableList then O=O..","end end;O=O.." in"for p=1,#o.Generators do O=n(O,m(o.Generators[p]))if p~=#o.Generators then O=n(O,',')end end;O=n(O,"do")O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='NumericForStatement'then o.Scope:ObfuscateVariables()O="for "O=O..o.Variable.Name.."="O=O..m(o.Start)..","..m(o.End)if o.Step then O=O..","..m(o.Step)end;O=n(O,"do")O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='LabelStatement'then O=getIndentation().."::"..o.Label.."::"elseif o.AstType=='GotoStatement'then O=getIndentation().."goto "..o.Label elseif o.AstType=='Comment'then elseif o.AstType=='Eof'then else print("Unknown AST Type: "..o.AstType)end;M=M+#O;return O end;L=function(o)local O=''o.Scope:ObfuscateVariables()for p,P in pairs(o.Body)do O=n(O,N(P),';')end;return O end;l.Scope:ObfuscateVariables()return L(l)end;return K end;E[2]=function()local G=e()E[2]=function()return G end;return G end end;do local e=function()if"true"=="true"then __STRICT=true;function global()end;return end;local G=getmetatable(_G)if G==nil then G={}setmetatable(_G,G)end;__STRICT=true;G.__declared={}G.__newindex=function(h,H,i)if __STRICT and not G.__declared[H]then local I=debug.getinfo(2,"S").what;if I~="main"and I~="C"then error("assign to undeclared variable '"..H.."'",2)end;G.__declared[H]=true end;rawset(h,H,i)end;G.__index=function(h,H)if not G.__declared[H]and debug.getinfo(2,"S").what~="C"then error("variable '"..H.."' is not declared",2)end;return rawget(h,H)end;function global(...)for h,H in ipairs{...}do G.__declared[H]=true end end end;E[4]=function()local G=e()E[4]=function()return G end;return G end end;do local e=function()local function G(j)for J,k in pairs(j)do j[k]=true end;return j end;local function h(j)local J=0;for k in pairs(j)do J=J+1 end;return J end;local function H(j,J)if j.Print then return j.Print()end;J=J or 0;local k=(h(j)>1)local K=string.rep('    ',J+1)local l="{".. (k and'\n'or'')for L,m in pairs(j)do if type(m)~='function'then l=l.. (k and K or'')if type(L)=='number'then elseif type(L)=='string'and L:match("^[A-Za-z_][A-Za-z0-9_]*$")then l=l..L.." = "elseif type(L)=='string'then l=l.."[\""..L.."\"] = "else l=l.."["..tostring(L).."] = "end;if type(m)=='string'then l=l.."\""..m.."\""elseif type(m)=='number'then l=l..m elseif type(m)=='table'then l=l..H(m,J+ (k and 1 or 0))else l=l..tostring(m)end;if next(j,L)then l=l..","end;if k then l=l..'\n'end end end;l=l.. (k and string.rep('    ',J)or'').."}"return l end;local function i(j)if j:match("\n")then local J={}for k in j:gmatch("[^\n]*")do table.insert(J,k)end;assert(#J>0)return J else return{j}end end;local function I(j,...)return print(string.format(j,...))end;return{PrintTable=H,CountTable=h,lookupify=G,splitLines=i,printf=I}end;E[3]=function()local G=e()E[3]=function()return G end;return G end end;do local e=function()E[4]()local h=E[3]()local G=h.lookupify;local H=G{' ','\n','\t','\r'}local i={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'"}local I=G{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local j=G{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local J=G{'0','1','2','3','4','5','6','7','8','9'}local k=G{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}local K=G{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local l=E[5]()local L=G{'and','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'}local function m(n)local N={}local o,O=pcall(function()local Q=1;local r=1;local R=1;local function s()local U=n:sub(Q,Q)if U=='\n'then R=1;r=r+1 else R=R+1 end;Q=Q+1;return U end;local function S(U)U=U or 0;return n:sub(Q+U,Q+U)end;local function t(U)local v=S()for V=1,#U do if v==U:sub(V,V)then return s()end end end;local function T(U)return error(">> :"..r..":"..R..": "..U,0)end;local function u()local U=Q;if S()=='['then local v=0;local V=1;while S(v+1)=='='do v=v+1 end;if S(v+1)=='['then for X=0,v+1 do s()end;local w=Q;while true do if S()==''then T("Expected `]"..string.rep('=',v).."]` near <eof>.",3)end;local X=true;if S()==']'then for y=1,v do if S(y)~='='then X=false end end;if S(v+1)~=']'then X=false end else if S()=='['then local y=true;for Y=1,v do if S(Y)~='='then y=false;break end end;if S(v+1)=='['and y then V=V+1;for Y=1,(v+2)do s()end end end;X=false end;if X then V=V-1;if V==0 then break else for y=1,v+2 do s()end end else s()end end;local W=n:sub(w,Q-1)for X=0,v+1 do s()end;local x=n:sub(U,Q-1)return W,x else return nil end else return nil end end;while true do local U={}local v=''local V=false;while true do local Y=S()if Y=='#'and S(1)=='!'and r==1 then s()s()v="#!"while S()~='\n'and S()~=''do v=v..s()end;local z={Type='Comment',CommentType='Shebang',Data=v,Line=r,Char=R}z.Print=function()return"<".. (z.Type..string.rep(' ',7-#z.Type)).."  ".. (z.Data or'').." >"end;v=""table.insert(U,z)end;if Y==' 'or Y=='\t'then local z=s()table.insert(U,{Type='Whitespace',Line=r,Char=R,Data=z})elseif Y=='\n'or Y=='\r'then local z=s()if v~=""then local Z={Type='Comment',CommentType=V and'LongComment'or'Comment',Data=v,Line=r,Char=R}Z.Print=function()return"<".. (Z.Type..string.rep(' ',7-#Z.Type)).."  ".. (Z.Data or'').." >"end;table.insert(U,Z)v=""end;table.insert(U,{Type='Whitespace',Line=r,Char=R,Data=z})elseif Y=='-'and S(1)=='-'then s()s()v=v..'--'local z,Z=u()if Z then v=v..Z;V=true else while S()~='\n'and S()~=''do v=v..s()end end else break end end;if v~=""then local Y={Type='Comment',CommentType=V and'LongComment'or'Comment',Data=v,Line=r,Char=R}Y.Print=function()return"<".. (Y.Type..string.rep(' ',7-#Y.Type)).."  ".. (Y.Data or'').." >"end;table.insert(U,Y)end;local w=r;local W=R;local x=":"..r..":"..R..":> "local X=S()local y=nil;if X==''then y={Type='Eof'}elseif j[X]or I[X]or X=='_'then local Y=Q;repeat s()X=S()until not(j[X]or I[X]or J[X]or X=='_')local z=n:sub(Y,Q-1)if L[z]then y={Type='Keyword',Data=z}else y={Type='Ident',Data=z}end elseif J[X]or(S()=='.'and J[S(1)])then local Y=Q;if X=='0'and S(1)=='x'then s()s()while k[S()]do s()end;if t('Pp')then t('+-')while J[S()]do s()end end else while J[S()]do s()end;if t('.')then while J[S()]do s()end end;if t('Ee')then t('+-')while J[S()]do s()end end end;y={Type='Number',Data=n:sub(Y,Q-1)}elseif X=='\''or X=='\"'then local Y=Q;local z=s()local Z=Q;while true do local X=s()if X=='\\'then s()elseif X==z then break elseif X==''then T("Unfinished string near <eof>")end end;local _=n:sub(Z,Q-2)local aa=n:sub(Y,Q-1)y={Type='String',Data=aa,Constant=_}elseif X=='['then local Y,z=u()if z then y={Type='String',Data=z,Constant=Y}else s()y={Type='Symbol',Data='['}end elseif t('>=<')then if t('=')then y={Type='Symbol',Data=X..'='}else y={Type='Symbol',Data=X}end elseif t('~')then if t('=')then y={Type='Symbol',Data='~='}else T("Unexpected symbol `~` in source.",2)end elseif t('.')then if t('.')then if t('.')then y={Type='Symbol',Data='...'}else y={Type='Symbol',Data='..'}end else y={Type='Symbol',Data='.'}end elseif t(':')then if t(':')then y={Type='Symbol',Data='::'}else y={Type='Symbol',Data=':'}end elseif K[X]then s()y={Type='Symbol',Data=X}else local Y,z=u()if Y then y={Type='String',Data=z,Constant=Y}else T("Unexpected Symbol `"..X.."` in source.",2)end end;y.LeadingWhite=U;y.Line=w;y.Char=W;y.Print=function()return"<".. (y.Type..string.rep(' ',7-#y.Type)).."  ".. (y.Data or'').." >"end;N[#N+1]=y;if y.Type=='Eof'then break end end end)if not o then return false,O end;local p={}local P={}local q=1;function p:getp()return q end;function p:setp(Q)q=Q end;function p:getTokenList()return N end;function p:Peek(Q)Q=Q or 0;return N[math.min(#N,q+Q)]end;function p:Get(Q)local r=N[q]q=math.min(q+1,#N)if Q then table.insert(Q,r)end;return r end;function p:Is(Q)return p:Peek().Type==Q end;function p:Save()P[#P+1]=q end;function p:Commit()P[#P]=nil end;function p:Restore()q=P[#P]P[#P]=nil end;function p:ConsumeSymbol(Q,r)local R=self:Peek()if R.Type=='Symbol'then if Q then if R.Data==Q then self:Get(r)return true else return nil end else self:Get(r)return R end else return nil end end;function p:ConsumeKeyword(Q,r)local R=self:Peek()if R.Type=='Keyword'and R.Data==Q then self:Get(r)return true else return nil end end;function p:IsKeyword(Q)local r=p:Peek()return r.Type=='Keyword'and r.Data==Q end;function p:IsSymbol(Q)local r=p:Peek()return r.Type=='Symbol'and r.Data==Q end;function p:IsEof()return p:Peek().Type=='Eof'end;return true,p end;local function M(n)local r,R;if type(n)~='table'then r,R=m(n)else r,R=true,n end;if not r then return false,R end;local function s(Q)local y=">> :"..R:Peek().Line..":"..R:Peek().Char..": "..Q.."\n"local Y=0;if type(n)=='string'then for z in n:gmatch("[^\n]*\n?")do if z:sub(-1,-1)=='\n'then z=z:sub(1,-2)end;Y=Y+1;if Y==R:Peek().Line then y=y..">> `"..z:gsub('\t','    ').."`\n"for Z=1,R:Peek().Char do local _=z:sub(Z,Z)if _=='\t'then y=y..'    'else y=y..' 'end end;y=y.."   ^^^^"break end end end;return y end;local S=0;local t={'_','a','b','c','d'}local function T(Q)local y=l:new(Q)y.RenameVars=y.ObfuscateLocals;y.ObfuscateVariables=y.ObfuscateLocals;y.Print=function()return"<Scope>"end;return y end;local u;local U;local v,V,w,W;local function x(Q,y)local Y=T(Q)if not R:ConsumeSymbol('(',y)then return false,s("`(` expected.")end;local z={}local Z=false;while not R:ConsumeSymbol(')',y)do if R:Is('Ident')then local aA=Y:CreateLocal(R:Get(y).Data)z[#z+1]=aA;if not R:ConsumeSymbol(',',y)then if R:ConsumeSymbol(')',y)then break else return false,s("`)` expected.")end end elseif R:ConsumeSymbol('...',y)then Z=true;if not R:ConsumeSymbol(')',y)then return false,s("`...` must be the last argument of a function.")end;break else return false,s("Argument name or `...` expected")end end;local r,_=U(Y)if not r then return false,_ end;if not R:ConsumeKeyword('end',y)then return false,s("`end` expected after function body")end;local aa={}aa.AstType='Function'aa.Scope=Y;aa.Arguments=z;aa.Body=_;aa.VarArg=Z;aa.Tokens=y;return true,aa end;function w(Q)local y={}if R:ConsumeSymbol('(',y)then local r,Y=u(Q)if not r then return false,Y end;if not R:ConsumeSymbol(')',y)then return false,s("`)` Expected.")end;if false then Y.ParenCount=(Y.ParenCount or 0)+1;return true,Y else local z={}z.AstType='Parentheses'z.Inner=Y;z.Tokens=y;return true,z end elseif R:Is('Ident')then local Y=R:Get(y)local z=Q:GetLocal(Y.Data)if not z then z=Q:GetGlobal(Y.Data)if not z then z=Q:CreateGlobal(Y.Data)else z.References=z.References+1 end else z.References=z.References+1 end;local Z={}Z.AstType='VarExpr'Z.Name=Y.Data;Z.Variable=z;Z.Tokens=y;return true,Z else return false,s("primary expression expected")end end;function W(Q,y)local r,Y=w(Q)if not r then return false,Y end;while true do local z={}if R:IsSymbol('.')or R:IsSymbol(':')then local Z=R:Get(z).Data;if not R:Is('Ident')then return false,s("<Ident> expected.")end;local _=R:Get(z)local aa={}aa.AstType='MemberExpr'aa.Base=Y;aa.Indexer=Z;aa.Ident=_;aa.Tokens=z;Y=aa elseif not y and R:ConsumeSymbol('[',z)then local r,Z=u(Q)if not r then return false,Z end;if not R:ConsumeSymbol(']',z)then return false,s("`]` expected.")end;local _={}_.AstType='IndexExpr'_.Base=Y;_.Index=Z;_.Tokens=z;Y=_ elseif not y and R:ConsumeSymbol('(',z)then local Z={}while not R:ConsumeSymbol(')',z)do local r,aa=u(Q)if not r then return false,aa end;Z[#Z+1]=aa;if not R:ConsumeSymbol(',',z)then if R:ConsumeSymbol(')',z)then break else return false,s("`)` Expected.")end end end;local _={}_.AstType='CallExpr'_.Base=Y;_.Arguments=Z;_.Tokens=z;Y=_ elseif not y and R:Is('String')then local Z={}Z.AstType='StringCallExpr'Z.Base=Y;Z.Arguments={R:Get(z)}Z.Tokens=z;Y=Z elseif not y and R:IsSymbol('{')then local r,Z=v(Q)if not r then return false,Z end;local _={}_.AstType='TableCallExpr'_.Base=Y;_.Arguments={Z}_.Tokens=z;Y=_ else break end end;return true,Y end;function v(Q)local y={}if R:Is('Number')then local Y={}Y.AstType='NumberExpr'Y.Value=R:Get(y)Y.Tokens=y;return true,Y elseif R:Is('String')then local Y={}Y.AstType='StringExpr'Y.Value=R:Get(y)Y.Tokens=y;return true,Y elseif R:ConsumeKeyword('nil',y)then local Y={}Y.AstType='NilExpr'Y.Tokens=y;return true,Y elseif R:IsKeyword('false')or R:IsKeyword('true')then local Y={}Y.AstType='BooleanExpr'Y.Value=(R:Get(y).Data=='true')Y.Tokens=y;return true,Y elseif R:ConsumeSymbol('...',y)then local Y={}Y.AstType='DotsExpr'Y.Tokens=y;return true,Y elseif R:ConsumeSymbol('{',y)then local Y={}Y.AstType='ConstructorExpr'Y.EntryList={}while true do if R:IsSymbol('[',y)then R:Get(y)local r,z=u(Q)if not r then return false,s("Key Expression Expected")end;if not R:ConsumeSymbol(']',y)then return false,s("`]` Expected")end;if not R:ConsumeSymbol('=',y)then return false,s("`=` Expected")end;local r,Z=u(Q)if not r then return false,s("Value Expression Expected")end;Y.EntryList[#Y.EntryList+1]={Type='Key',Key=z,Value=Z}elseif R:Is('Ident')then local z=R:Peek(1)if z.Type=='Symbol'and z.Data=='='then local Z=R:Get(y)if not R:ConsumeSymbol('=',y)then return false,s("`=` Expected")end;local r,_=u(Q)if not r then return false,s("Value Expression Expected")end;Y.EntryList[#Y.EntryList+1]={Type='KeyString',Key=Z.Data,Value=_}else local r,Z=u(Q)if not r then return false,s("Value Exected")end;Y.EntryList[#Y.EntryList+1]={Type='Value',Value=Z}end elseif R:ConsumeSymbol('}',y)then break else local r,z=u(Q)Y.EntryList[#Y.EntryList+1]={Type='Value',Value=z}if not r then return false,s("Value Expected")end end;if R:ConsumeSymbol(';',y)or R:ConsumeSymbol(',',y)then elseif R:ConsumeSymbol('}',y)then break else return false,s("`}` or table entry Expected")end end;Y.Tokens=y;return true,Y elseif R:ConsumeKeyword('function',y)then local r,Y=x(Q,y)if not r then return false,Y end;Y.IsLocal=true;return true,Y else return W(Q)end end;local X=G{'-','not','#'}local N=8;local o={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}function V(Q,y)local r,Y;if X[R:Peek().Data]then local z={}local Z=R:Get(z).Data;r,Y=V(Q,N)if not r then return false,Y end;local _={}_.AstType='UnopExpr'_.Rhs=Y;_.Op=Z;_.OperatorPrecedence=N;_.Tokens=z;Y=_ else r,Y=v(Q)if not r then return false,Y end end;while true do local z=o[R:Peek().Data]if z and z[1]>y then local Z={}local _=R:Get(Z).Data;local r,aa=V(Q,z[2])if not r then return false,aa end;local aA={}aA.AstType='BinopExpr'aA.Lhs=Y;aA.Op=_;aA.OperatorPrecedence=z[1]aA.Rhs=aa;aA.Tokens=Z;Y=aA else break end end;return true,Y end;u=function(Q)return V(Q,0)end;local function O(Q)local y=nil;local Y={}if R:ConsumeKeyword('if',Y)then local z={}z.AstType='IfStatement'z.Clauses={}repeat local r,Z=u(Q)if not r then return false,Z end;if not R:ConsumeKeyword('then',Y)then return false,s("`then` expected.")end;local r,_=U(Q)if not r then return false,_ end;z.Clauses[#z.Clauses+1]={Condition=Z,Body=_}until not R:ConsumeKeyword('elseif',Y)if R:ConsumeKeyword('else',Y)then local r,Z=U(Q)if not r then return false,Z end;z.Clauses[#z.Clauses+1]={Body=Z}end;if not R:ConsumeKeyword('end',Y)then return false,s("`end` expected.")end;z.Tokens=Y;y=z elseif R:ConsumeKeyword('while',Y)then local z={}z.AstType='WhileStatement'local r,Z=u(Q)if not r then return false,Z end;if not R:ConsumeKeyword('do',Y)then return false,s("`do` expected.")end;local r,_=U(Q)if not r then return false,_ end;if not R:ConsumeKeyword('end',Y)then return false,s("`end` expected.")end;z.Condition=Z;z.Body=_;z.Tokens=Y;y=z elseif R:ConsumeKeyword('do',Y)then local r,z=U(Q)if not r then return false,z end;if not R:ConsumeKeyword('end',Y)then return false,s("`end` expected.")end;local Z={}Z.AstType='DoStatement'Z.Body=z;Z.Tokens=Y;y=Z elseif R:ConsumeKeyword('for',Y)then if not R:Is('Ident')then return false,s("<ident> expected.")end;local z=R:Get(Y)if R:ConsumeSymbol('=',Y)then local Z=T(Q)local _=Z:CreateLocal(z.Data)local r,aa=u(Q)if not r then return false,aa end;if not R:ConsumeSymbol(',',Y)then return false,s("`,` Expected")end;local r,aA=u(Q)if not r then return false,aA end;local r,ab;if R:ConsumeSymbol(',',Y)then r,ab=u(Q)if not r then return false,ab end end;if not R:ConsumeKeyword('do',Y)then return false,s("`do` expected")end;local r,aB=U(Z)if not r then return false,aB end;if not R:ConsumeKeyword('end',Y)then return false,s("`end` expected")end;local ac={}ac.AstType='NumericForStatement'ac.Scope=Z;ac.Variable=_;ac.Start=aa;ac.End=aA;ac.Step=ab;ac.Body=aB;ac.Tokens=Y;y=ac else local Z=T(Q)local _={Z:CreateLocal(z.Data)}while R:ConsumeSymbol(',',Y)do if not R:Is('Ident')then return false,s("for variable expected.")end;_[#_+1]=Z:CreateLocal(R:Get(Y).Data)end;if not R:ConsumeKeyword('in',Y)then return false,s("`in` expected.")end;local aa={}local r,aA=u(Q)if not r then return false,aA end;aa[#aa+1]=aA;while R:ConsumeSymbol(',',Y)do local r,ac=u(Q)if not r then return false,ac end;aa[#aa+1]=ac end;if not R:ConsumeKeyword('do',Y)then return false,s("`do` expected.")end;local r,ab=U(Z)if not r then return false,ab end;if not R:ConsumeKeyword('end',Y)then return false,s("`end` expected.")end;local aB={}aB.AstType='GenericForStatement'aB.Scope=Z;aB.VariableList=_;aB.Generators=aa;aB.Body=ab;aB.Tokens=Y;y=aB end elseif R:ConsumeKeyword('repeat',Y)then local r,z=U(Q)if not r then return false,z end;if not R:ConsumeKeyword('until',Y)then return false,s("`until` expected.")end;local r,Z=u(z.Scope)if not r then return false,Z end;local _={}_.AstType='RepeatStatement'_.Condition=Z;_.Body=z;_.Tokens=Y;y=_ elseif R:ConsumeKeyword('function',Y)then if not R:Is('Ident')then return false,s("Function name expected")end;local r,z=W(Q,true)if not r then return false,z end;local r,Z=x(Q,Y)if not r then return false,Z end;Z.IsLocal=false;Z.Name=z;y=Z elseif R:ConsumeKeyword('local',Y)then if R:Is('Ident')then local z={R:Get(Y).Data}while R:ConsumeSymbol(',',Y)do if not R:Is('Ident')then return false,s("local var name expected")end;z[#z+1]=R:Get(Y).Data end;local Z={}if R:ConsumeSymbol('=',Y)then repeat local r,aa=u(Q)if not r then return false,aa end;Z[#Z+1]=aa until not R:ConsumeSymbol(',',Y)end;for aa,aA in pairs(z)do z[aa]=Q:CreateLocal(aA)end;local _={}_.AstType='LocalStatement'_.LocalList=z;_.InitList=Z;_.Tokens=Y;y=_ elseif R:ConsumeKeyword('function',Y)then if not R:Is('Ident')then return false,s("Function name expected")end;local z=R:Get(Y).Data;local Z=Q:CreateLocal(z)local r,_=x(Q,Y)if not r then return false,_ end;_.Name=Z;_.IsLocal=true;y=_ else return false,s("local var or function def expected")end elseif R:ConsumeSymbol('::',Y)then if not R:Is('Ident')then return false,s('Label name expected')end;local z=R:Get(Y).Data;if not R:ConsumeSymbol('::',Y)then return false,s("`::` expected")end;local Z={}Z.AstType='LabelStatement'Z.Label=z;Z.Tokens=Y;y=Z elseif R:ConsumeKeyword('return',Y)then local z={}if not R:IsKeyword('end')then local r,_=u(Q)if r then z[1]=_;while R:ConsumeSymbol(',',Y)do local r,aa=u(Q)if not r then return false,aa end;z[#z+1]=aa end end end;local Z={}Z.AstType='ReturnStatement'Z.Arguments=z;Z.Tokens=Y;y=Z elseif R:ConsumeKeyword('break',Y)then local z={}z.AstType='BreakStatement'z.Tokens=Y;y=z elseif R:ConsumeKeyword('goto',Y)then if not R:Is('Ident')then return false,s("Label expected")end;local z=R:Get(Y).Data;local Z={}Z.AstType='GotoStatement'Z.Label=z;Z.Tokens=Y;y=Z else local r,z=W(Q)if not r then return false,z end;if R:IsSymbol(',')or R:IsSymbol('=')then if(z.ParenCount or 0)>0 then return false,s("Can not assign to parenthesized expression, is not an lvalue")end;local Z={z}while R:ConsumeSymbol(',',Y)do local r,ab=W(Q)if not r then return false,ab end;Z[#Z+1]=ab end;if not R:ConsumeSymbol('=',Y)then return false,s("`=` Expected.")end;local _={}local r,aa=u(Q)if not r then return false,aa end;_[1]=aa;while R:ConsumeSymbol(',',Y)do local r,ab=u(Q)if not r then return false,ab end;_[#_+1]=ab end;local aA={}aA.AstType='AssignmentStatement'aA.Lhs=Z;aA.Rhs=_;aA.Tokens=Y;y=aA elseif z.AstType=='CallExpr'or z.AstType=='TableCallExpr'or z.AstType=='StringCallExpr'then local Z={}Z.AstType='CallStatement'Z.Expression=z;Z.Tokens=Y;y=Z else return false,s("Assignment Statement Expected")end end;if R:IsSymbol(';')then y.Semicolon=R:Get(y.Tokens)end;return true,y end;local p=G{'end','else','elseif','until'}U=function(Q)local y={}y.Scope=T(Q)y.AstType='Statlist'y.Body={}y.Tokens={}while not p[R:Peek().Data]and not R:IsEof()do local r,Y=O(y.Scope)if not r then return false,Y end;y.Body[#y.Body+1]=Y end;if R:IsEof()then local Y={}Y.AstType='Eof'Y.Tokens={R:Get()}y.Body[#y.Body+1]=Y end;return true,y end;local function P()local Q=T()return U(Q)end;local r,q=P()return r,q end;return{LexLua=m,ParseLua=M}end;E[1]=function()local G=e()E[1]=function()return G end;return G end end;local f=E[1]()local g=E[2]()local F=f.ParseLua;local a={}local function A(e)return e:match("(.*/)")or"./"end;local function b(e)e=e:gsub("\\","/")e=e:gsub("//","/")local G={}for h in e:gmatch("[^/]+")do if h==".."then table.remove(G)elseif h~="."then table.insert(G,h)end end;return table.concat(G,"/")end;local function B(e,G)G=G and(G:match("/$")and G or G.."/")or""local h={e,G..e,G..e..".lua"}for i,I in ipairs(h)do local H=io.open(I,"r")if H then local j=H:read("*all")H:close()return j,I end end;return nil end;function a.bundle(e,J,k,G,h,H,i,I)e=a.minifyLua(e)J=J or J==nil;k=k or nil;h=h or{}H=H or{}local j={}I=I or 1;i=i==nil and"__MODULES_"..a.makeid(25)or i;local function l(K)local function m(M)local N=io.open(G..M,"r")or io.open(G..M..".lua","r")if not N then return("require\"%s\""):format(M)end;N:close()local o=h[M]or I;if not h[M]then h[M]=I;I=I+1 end;if k then j[k]=j[k]or{}table.insert(j[k],M)end;return i.."["..o.."]()"end;K=K:gsub('require%s*[%(%s]*([%\'"%[])(.-)%1[%)%s]*',function(n,N)return m(N)end)K=K:gsub('%true%',function()return"true"end)return K end;local L=l(e)for K,m in pairs(h)do if not H[K]then local M=B(K,G)if M then H[K]=M;local n=a.bundle(M,false,K,G,h,H,i,I)H[K]=n else print("WARNING: Failed to read module "..K)end end end;if J then local K=string.format([[
local %s = {}
]],i)for M,n in pairs(h)do K=K..string.format([[
do
    local module = function()
        %s
    end
    %s[%d] = function()
        local ret = module()
        %s[%d] = function() return ret end
        return ret
    end
end
]],H[M],i,n,i,n)end;L=K..L end;return L end;function a.makeid(e)local i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"local I="0123456789"local G=""local h=true;for H=1,e do local J=h and i or(i..I)local k=math.random(#J)G=G..J:sub(k,k)h=false end;return G end;function a.removeComments(e)e=e:gsub("%-%-.-\n","\n")e=e:gsub("%-%-%[%[.-%]%]","")return e end;function a.minifyLua(e)local h,H=F(e)if not h then error(H)return end;return g(H)end;function a.writeFile(e,G)local h=io.open(e,"w")if not h then return false end;h:write(G)h:close()return true end;function a.main(e,G)e=e or"main.lua"G=G or"bundled.min.lua"local I,j=B(e)if not I then print("ERROR: Cannot read "..e)return false end;local h=a.bundle(I,true,nil,A(j))local H=a.minifyLua(h)if a.writeFile(G,H)then print("Bundling and minification completed successfully.")return true else print("Failed to write "..G)return false end end;math.randomseed(os.time())local c={...}if#c<1 then error("Usage: bundle.lua [entrypoint] [?-o output]")end;local C=c[1]local d=""do local e={}for G in C:gmatch("([^.]+)")do table.insert(e,G)end;if#e>1 and e[#e]=="lua"then table.remove(e,#e)end;d=table.concat(e,".")end;local D=d..".min.lua"for e=2,#c-1 do if c[e]:lower()=="-o"then D=c[e+1]end end;a.main(C,D)