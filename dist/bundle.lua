local E={}do local e=function()if true then __STRICT=true;function global()end;return end;local H=getmetatable(_G)if H==nil then H={}setmetatable(_G,H)end;__STRICT=true;H.__declared={}H.__newindex=function(i,I,j)if __STRICT and not H.__declared[I]then local J=debug.getinfo(2,"S").what;if J~="main"and J~="C"then error("assign to undeclared variable '"..I.."'",2)end;H.__declared[I]=true end;rawset(i,I,j)end;H.__index=function(i,I)if not H.__declared[I]and debug.getinfo(2,"S").what~="C"then error("variable '"..I.."' is not declared",2)end;return rawget(i,I)end;function global(...)for i,I in ipairs{...}do H.__declared[I]=true end end end;E[3]=function()local H=e()E[3]=function()return H end;return H end end;do local e=function()local function H(k)for K,l in pairs(k)do k[l]=true end;return k end;local function i(k)local K=0;for l in pairs(k)do K=K+1 end;return K end;local function I(k,K)if k.Print then return k.Print()end;K=K or 0;local l=(i(k)>1)local L=string.rep('    ',K+1)local m="{".. (l and'\n'or'')for M,n in pairs(k)do if type(n)~='function'then m=m.. (l and L or'')if type(M)=='number'then elseif type(M)=='string'and M:match("^[A-Za-z_][A-Za-z0-9_]*$")then m=m..M.." = "elseif type(M)=='string'then m=m.."[\""..M.."\"] = "else m=m.."["..tostring(M).."] = "end;if type(n)=='string'then m=m.."\""..n.."\""elseif type(n)=='number'then m=m..n elseif type(n)=='table'then m=m..I(n,K+ (l and 1 or 0))else m=m..tostring(n)end;if next(k,M)then m=m..","end;if l then m=m..'\n'end end end;m=m.. (l and string.rep('    ',K)or'').."}"return m end;local function j(k)if k:match("\n")then local K={}for l in k:gmatch("[^\n]*")do table.insert(K,l)end;assert(#K>0)return K else return{k}end end;local function J(k,...)return print(string.format(k,...))end;return{PrintTable=I,CountTable=i,lookupify=H,splitLines=j,printf=J}end;E[4]=function()local H=e()E[4]=function()return H end;return H end end;do local e=function()E[3]()local H=E[4]()local i=H.lookupify;local I=i{' ','\n','\t','\r'}local j={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'"}local J=i{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local k=i{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local K=i{'0','1','2','3','4','5','6','7','8','9'}local l=i{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}local L=i{',','{','}','[',']','(',')',';','#'}local m=E[5]()local M=i{'and','continue','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'}local function n(o)local O={}local p,P=pcall(function()local R=1;local s=1;local S=1;local function t()local V=o:sub(R,R)if V=='\n'then S=1;s=s+1 else S=S+1 end;R=R+1;return V end;local function T(V)V=V or 0;return o:sub(R+V,R+V)end;local function u(V)local w=T()for W=1,#V do if w==V:sub(W,W)then return t()end end end;local function U(V)return error(">> :"..s..":"..S..": "..V,0)end;local function v()local V=R;if T()=='['then local w=0;local W=1;while T(w+1)=='='do w=w+1 end;if T(w+1)=='['then for Y=0,w+1 do t()end;local x=R;while true do if T()==''then U("Expected `]"..string.rep('=',w).."]` near <eof>.",3)end;local Y=true;if T()==']'then for z=1,w do if T(z)~='='then Y=false end end;if T(w+1)~=']'then Y=false end else if T()=='['then local z=true;for Z=1,w do if T(Z)~='='then z=false;break end end;if T(w+1)=='['and z then W=W+1;for Z=1,(w+2)do t()end end end;Y=false end;if Y then W=W-1;if W==0 then break else for z=1,w+2 do t()end end else t()end end;local X=o:sub(x,R-1)for Y=0,w+1 do t()end;local y=o:sub(V,R-1)return X,y else return nil end else return nil end end;while true do local V={}local w=''local W=false;while true do local Z=T()if Z=='#'and T(1)=='!'and s==1 then t()t()w="#!"while T()~='\n'and T()~=''do w=w..t()end;local _={Type='Comment',CommentType='Shebang',Data=w,Line=s,Char=S}_.Print=function()return"<".. (_.Type..string.rep(' ',7-#_.Type)).."  ".. (_.Data or'').." >"end;w=""table.insert(V,_)end;if Z==' 'or Z=='\t'then local _=t()table.insert(V,{Type='Whitespace',Line=s,Char=S,Data=_})elseif Z=='\n'or Z=='\r'then local _=t()if w~=""then local aa={Type='Comment',CommentType=W and'LongComment'or'Comment',Data=w,Line=s,Char=S}aa.Print=function()return"<".. (aa.Type..string.rep(' ',7-#aa.Type)).."  ".. (aa.Data or'').." >"end;table.insert(V,aa)w=""end;table.insert(V,{Type='Whitespace',Line=s,Char=S,Data=_})elseif Z=='-'and T(1)=='-'then t()t()w=w..'--'local _,aa=v()if aa then w=w..aa;W=true else while T()~='\n'and T()~=''do w=w..t()end end else break end end;if w~=""then local Z={Type='Comment',CommentType=W and'LongComment'or'Comment',Data=w,Line=s,Char=S}Z.Print=function()return"<".. (Z.Type..string.rep(' ',7-#Z.Type)).."  ".. (Z.Data or'').." >"end;table.insert(V,Z)end;local x=s;local X=S;local y=":"..s..":"..S..":> "local Y=T()local z=nil;if Y==''then z={Type='Eof'}elseif k[Y]or J[Y]or Y=='_'then local Z=R;repeat t()Y=T()until not(k[Y]or J[Y]or K[Y]or Y=='_')local _=o:sub(Z,R-1)if M[_]then z={Type='Keyword',Data=_}else z={Type='Ident',Data=_}end elseif K[Y]or(T()=='.'and K[T(1)])then local Z=R;if Y=='0'and T(1)=='x'then t()t()while l[T()]do t()end;if u('Pp')then u('+-')while K[T()]do t()end end else while K[T()]do t()end;if u('.')then while K[T()]do t()end end;if u('Ee')then u('+-')while K[T()]do t()end end end;z={Type='Number',Data=o:sub(Z,R-1)}elseif Y=='\''or Y=='\"'then local Z=R;local _=t()local aa=R;while true do local Y=t()if Y=='\\'then t()elseif Y==_ then break elseif Y==''then U("Unfinished string near <eof>")end end;local aA=o:sub(aa,R-2)local ab=o:sub(Z,R-1)z={Type='String',Data=ab,Constant=aA}elseif Y=='['then local Z,_=v()if _ then z={Type='String',Data=_,Constant=Z}else t()z={Type='Symbol',Data='['}end elseif u('>=<')then if u('=')then z={Type='Symbol',Data=Y..'='}else z={Type='Symbol',Data=Y}end elseif u('~')then if u('=')then z={Type='Symbol',Data='~='}else U("Unexpected symbol `~` in source.",2)end elseif u('.')then if u('.')then if u('.')then z={Type='Symbol',Data='...'}else z={Type='Symbol',Data='..'}end else z={Type='Symbol',Data='.'}end elseif u(':')then if u(':')then z={Type='Symbol',Data='::'}else z={Type='Symbol',Data=':'}end elseif Y=='+'or Y=='-'or Y=='*'or Y=='/'or Y=='%'or Y=='^'then local Z=t()if T()=='='then t()z={Type='Symbol',Data=Z..'='}else z={Type='Symbol',Data=Z}end elseif L[Y]then t()z={Type='Symbol',Data=Y}else local Z,_=v()if Z then z={Type='String',Data=_,Constant=Z}else U("Unexpected Symbol `"..Y.."` in source.",2)end end;z.LeadingWhite=V;z.Line=x;z.Char=X;z.Print=function()return"<".. (z.Type..string.rep(' ',7-#z.Type)).."  ".. (z.Data or'').." >"end;O[#O+1]=z;if z.Type=='Eof'then break end end end)if not p then return false,P end;local q={}local Q={}local r=1;function q:getp()return r end;function q:setp(R)r=R end;function q:getTokenList()return O end;function q:Peek(R)R=R or 0;return O[math.min(#O,r+R)]end;function q:Get(R)local s=O[r]r=math.min(r+1,#O)if R then table.insert(R,s)end;return s end;function q:Is(R)return q:Peek().Type==R end;function q:Save()Q[#Q+1]=r end;function q:Commit()Q[#Q]=nil end;function q:Restore()r=Q[#Q]Q[#Q]=nil end;function q:ConsumeSymbol(R,s)local S=self:Peek()if S.Type=='Symbol'then if R then if S.Data==R then self:Get(s)return true else return nil end else self:Get(s)return S end else return nil end end;function q:ConsumeKeyword(R,s)local S=self:Peek()if S.Type=='Keyword'and S.Data==R then self:Get(s)return true else return nil end end;function q:IsKeyword(R)local s=q:Peek()return s.Type=='Keyword'and s.Data==R end;function q:IsSymbol(R)local s=q:Peek()return s.Type=='Symbol'and s.Data==R end;function q:IsEof()return q:Peek().Type=='Eof'end;return true,q end;local function N(o)local R,s;if type(o)~='table'then R,s=n(o)else R,s=true,o end;if not R then return false,s end;local function S(r)local Z=">> :"..s:Peek().Line..":"..s:Peek().Char..": "..r.."\n"local _=0;if type(o)=='string'then for aa in o:gmatch("[^\n]*\n?")do if aa:sub(-1,-1)=='\n'then aa=aa:sub(1,-2)end;_=_+1;if _==s:Peek().Line then Z=Z..">> `"..aa:gsub('\t','    ').."`\n"for aA=1,s:Peek().Char do local ab=aa:sub(aA,aA)if ab=='\t'then Z=Z..'    'else Z=Z..' 'end end;Z=Z.."   ^^^^"break end end end;return Z end;local t=0;local T={'_','a','b','c','d'}local function u(r)local Z=m:new(r)Z.RenameVars=Z.ObfuscateLocals;Z.ObfuscateVariables=Z.ObfuscateLocals;Z.Print=function()return"<Scope>"end;return Z end;local U;local v;local V,w,W,x;local function X(r,Z)local _=u(r)if not s:ConsumeSymbol('(',Z)then return false,S("`(` expected.")end;local aa={}local aA=false;while not s:ConsumeSymbol(')',Z)do if s:Is('Ident')then local ac=_:CreateLocal(s:Get(Z).Data)aa[#aa+1]=ac;if not s:ConsumeSymbol(',',Z)then if s:ConsumeSymbol(')',Z)then break else return false,S("`)` expected.")end end elseif s:ConsumeSymbol('...',Z)then aA=true;if not s:ConsumeSymbol(')',Z)then return false,S("`...` must be the last argument of a function.")end;break else return false,S("Argument name or `...` expected")end end;local R,ab=v(_)if not R then return false,ab end;if not s:ConsumeKeyword('end',Z)then return false,S("`end` expected after function body")end;local aB={}aB.AstType='Function'aB.Scope=_;aB.Arguments=aa;aB.Body=ab;aB.VarArg=aA;aB.Tokens=Z;return true,aB end;function W(r)local Z={}if s:ConsumeSymbol('(',Z)then local R,_=U(r)if not R then return false,_ end;if not s:ConsumeSymbol(')',Z)then return false,S("`)` Expected.")end;if false then _.ParenCount=(_.ParenCount or 0)+1;return true,_ else local aa={}aa.AstType='Parentheses'aa.Inner=_;aa.Tokens=Z;return true,aa end elseif s:Is('Ident')then local _=s:Get(Z)local aa=r:GetLocal(_.Data)if not aa then aa=r:GetGlobal(_.Data)if not aa then aa=r:CreateGlobal(_.Data)else aa.References=aa.References+1 end else aa.References=aa.References+1 end;local aA={}aA.AstType='VarExpr'aA.Name=_.Data;aA.Variable=aa;aA.Tokens=Z;return true,aA else return false,S("primary expression expected")end end;function x(r,Z)local R,_=W(r)if not R then return false,_ end;while true do local aa={}if s:IsSymbol('.')or s:IsSymbol(':')then local aA=s:Get(aa).Data;if not s:Is('Ident')then return false,S("<Ident> expected.")end;local ab=s:Get(aa)local aB={}aB.AstType='MemberExpr'aB.Base=_;aB.Indexer=aA;aB.Ident=ab;aB.Tokens=aa;_=aB elseif not Z and s:ConsumeSymbol('[',aa)then local R,aA=U(r)if not R then return false,aA end;if not s:ConsumeSymbol(']',aa)then return false,S("`]` expected.")end;local ab={}ab.AstType='IndexExpr'ab.Base=_;ab.Index=aA;ab.Tokens=aa;_=ab elseif not Z and s:ConsumeSymbol('(',aa)then local aA={}while not s:ConsumeSymbol(')',aa)do local R,aB=U(r)if not R then return false,aB end;aA[#aA+1]=aB;if not s:ConsumeSymbol(',',aa)then if s:ConsumeSymbol(')',aa)then break else return false,S("`)` Expected.")end end end;local ab={}ab.AstType='CallExpr'ab.Base=_;ab.Arguments=aA;ab.Tokens=aa;_=ab elseif not Z and s:Is('String')then local aA={}aA.AstType='StringCallExpr'aA.Base=_;aA.Arguments={s:Get(aa)}aA.Tokens=aa;_=aA elseif not Z and s:IsSymbol('{')then local R,aA=V(r)if not R then return false,aA end;local ab={}ab.AstType='TableCallExpr'ab.Base=_;ab.Arguments={aA}ab.Tokens=aa;_=ab else break end end;return true,_ end;function V(r)local Z={}if s:Is('Number')then local _={}_.AstType='NumberExpr'_.Value=s:Get(Z)_.Tokens=Z;return true,_ elseif s:Is('String')then local _={}_.AstType='StringExpr'_.Value=s:Get(Z)_.Tokens=Z;return true,_ elseif s:ConsumeKeyword('nil',Z)then local _={}_.AstType='NilExpr'_.Tokens=Z;return true,_ elseif s:IsKeyword('false')or s:IsKeyword('true')then local _={}_.AstType='BooleanExpr'_.Value=(s:Get(Z).Data=='true')_.Tokens=Z;return true,_ elseif s:ConsumeSymbol('...',Z)then local _={}_.AstType='DotsExpr'_.Tokens=Z;return true,_ elseif s:ConsumeSymbol('{',Z)then local _={}_.AstType='ConstructorExpr'_.EntryList={}while true do if s:IsSymbol('[',Z)then s:Get(Z)local R,aa=U(r)if not R then return false,S("Key Expression Expected")end;if not s:ConsumeSymbol(']',Z)then return false,S("`]` Expected")end;if not s:ConsumeSymbol('=',Z)then return false,S("`=` Expected")end;local R,aA=U(r)if not R then return false,S("Value Expression Expected")end;_.EntryList[#_.EntryList+1]={Type='Key',Key=aa,Value=aA}elseif s:Is('Ident')then local aa=s:Peek(1)if aa.Type=='Symbol'and aa.Data=='='then local aA=s:Get(Z)if not s:ConsumeSymbol('=',Z)then return false,S("`=` Expected")end;local R,ab=U(r)if not R then return false,S("Value Expression Expected")end;_.EntryList[#_.EntryList+1]={Type='KeyString',Key=aA.Data,Value=ab}else local R,aA=U(r)if not R then return false,S("Value Exected")end;_.EntryList[#_.EntryList+1]={Type='Value',Value=aA}end elseif s:ConsumeSymbol('}',Z)then break else local R,aa=U(r)_.EntryList[#_.EntryList+1]={Type='Value',Value=aa}if not R then return false,S("Value Expected")end end;if s:ConsumeSymbol(';',Z)or s:ConsumeSymbol(',',Z)then elseif s:ConsumeSymbol('}',Z)then break else return false,S("`}` or table entry Expected")end end;_.Tokens=Z;return true,_ elseif s:ConsumeKeyword('function',Z)then local R,_=X(r,Z)if not R then return false,_ end;_.IsLocal=true;return true,_ elseif s:ConsumeKeyword('if',Z)then local _,aa=U(r)if not _ then return false,aa end;if not s:ConsumeKeyword('then',Z)then return false,S("`then` expected in if-expression")end;local aA,ab=U(r)if not aA then return false,ab end;if not s:ConsumeKeyword('else',Z)then return false,S("`else` expected in if-expression")end;local aB,ac=U(r)if not aB then return false,ac end;local aC={}aC.AstType='IfExpression'aC.Condition=aa;aC.TrueExpression=ab;aC.FalseExpression=ac;aC.Tokens=Z;return true,aC else return x(r)end end;local y=i{'-','not','#'}local Y=i{'+=','-=','*=','/=','%=','^='}local z=8;local O={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}function w(r,Z)local R,_;if y[s:Peek().Data]then local aa={}local aA=s:Get(aa).Data;R,_=w(r,z)if not R then return false,_ end;local ab={}ab.AstType='UnopExpr'ab.Rhs=_;ab.Op=aA;ab.OperatorPrecedence=z;ab.Tokens=aa;_=ab else R,_=V(r)if not R then return false,_ end end;while true do local aa=O[s:Peek().Data]if aa and aa[1]>Z then local aA={}local ab=s:Get(aA).Data;local R,aB=w(r,aa[2])if not R then return false,aB end;local ac={}ac.AstType='BinopExpr'ac.Lhs=_;ac.Op=ab;ac.OperatorPrecedence=aa[1]ac.Rhs=aB;ac.Tokens=aA;_=ac else break end end;return true,_ end;U=function(r)return w(r,0)end;local function p(r)local Z=nil;local _={}if s:ConsumeKeyword('if',_)then local aa={}aa.AstType='IfStatement'aa.Clauses={}repeat local R,aA=U(r)if not R then return false,aA end;if not s:ConsumeKeyword('then',_)then return false,S("`then` expected.")end;local R,ab=v(r)if not R then return false,ab end;aa.Clauses[#aa.Clauses+1]={Condition=aA,Body=ab}until not s:ConsumeKeyword('elseif',_)if s:ConsumeKeyword('else',_)then local R,aA=v(r)if not R then return false,aA end;aa.Clauses[#aa.Clauses+1]={Body=aA}end;if not s:ConsumeKeyword('end',_)then return false,S("`end` expected.")end;aa.Tokens=_;Z=aa elseif s:ConsumeKeyword('while',_)then local aa={}aa.AstType='WhileStatement'local R,aA=U(r)if not R then return false,aA end;if not s:ConsumeKeyword('do',_)then return false,S("`do` expected.")end;local R,ab=v(r)if not R then return false,ab end;if not s:ConsumeKeyword('end',_)then return false,S("`end` expected.")end;aa.Condition=aA;aa.Body=ab;aa.Tokens=_;Z=aa elseif s:ConsumeKeyword('do',_)then local R,aa=v(r)if not R then return false,aa end;if not s:ConsumeKeyword('end',_)then return false,S("`end` expected.")end;local aA={}aA.AstType='DoStatement'aA.Body=aa;aA.Tokens=_;Z=aA elseif s:ConsumeKeyword('for',_)then if not s:Is('Ident')then return false,S("<ident> expected.")end;local aa=s:Get(_)if s:ConsumeSymbol('=',_)then local aA=u(r)local ab=aA:CreateLocal(aa.Data)local R,aB=U(r)if not R then return false,aB end;if not s:ConsumeSymbol(',',_)then return false,S("`,` Expected")end;local R,ac=U(r)if not R then return false,ac end;local R,aC;if s:ConsumeSymbol(',',_)then R,aC=U(r)if not R then return false,aC end end;if not s:ConsumeKeyword('do',_)then return false,S("`do` expected")end;local R,ad=v(aA)if not R then return false,ad end;if not s:ConsumeKeyword('end',_)then return false,S("`end` expected")end;local aD={}aD.AstType='NumericForStatement'aD.Scope=aA;aD.Variable=ab;aD.Start=aB;aD.End=ac;aD.Step=aC;aD.Body=ad;aD.Tokens=_;Z=aD else local aA=u(r)local ab={aA:CreateLocal(aa.Data)}while s:ConsumeSymbol(',',_)do if not s:Is('Ident')then return false,S("for variable expected.")end;ab[#ab+1]=aA:CreateLocal(s:Get(_).Data)end;if not s:ConsumeKeyword('in',_)then return false,S("`in` expected.")end;local aB={}local R,ac=U(r)if not R then return false,ac end;aB[#aB+1]=ac;while s:ConsumeSymbol(',',_)do local R,aD=U(r)if not R then return false,aD end;aB[#aB+1]=aD end;if not s:ConsumeKeyword('do',_)then return false,S("`do` expected.")end;local R,aC=v(aA)if not R then return false,aC end;if not s:ConsumeKeyword('end',_)then return false,S("`end` expected.")end;local ad={}ad.AstType='GenericForStatement'ad.Scope=aA;ad.VariableList=ab;ad.Generators=aB;ad.Body=aC;ad.Tokens=_;Z=ad end elseif s:ConsumeKeyword('repeat',_)then local R,aa=v(r)if not R then return false,aa end;if not s:ConsumeKeyword('until',_)then return false,S("`until` expected.")end;local R,aA=U(aa.Scope)if not R then return false,aA end;local ab={}ab.AstType='RepeatStatement'ab.Condition=aA;ab.Body=aa;ab.Tokens=_;Z=ab elseif s:ConsumeKeyword('function',_)then if not s:Is('Ident')then return false,S("Function name expected")end;local R,aa=x(r,true)if not R then return false,aa end;local R,aA=X(r,_)if not R then return false,aA end;aA.IsLocal=false;aA.Name=aa;Z=aA elseif s:ConsumeKeyword('local',_)then if s:Is('Ident')then local aa={s:Get(_).Data}while s:ConsumeSymbol(',',_)do if not s:Is('Ident')then return false,S("local var name expected")end;aa[#aa+1]=s:Get(_).Data end;local aA={}if s:ConsumeSymbol('=',_)then repeat local R,aB=U(r)if not R then return false,aB end;aA[#aA+1]=aB until not s:ConsumeSymbol(',',_)end;for aB,ac in pairs(aa)do aa[aB]=r:CreateLocal(ac)end;local ab={}ab.AstType='LocalStatement'ab.LocalList=aa;ab.InitList=aA;ab.Tokens=_;Z=ab elseif s:ConsumeKeyword('function',_)then if not s:Is('Ident')then return false,S("Function name expected")end;local aa=s:Get(_).Data;local aA=r:CreateLocal(aa)local R,ab=X(r,_)if not R then return false,ab end;ab.Name=aA;ab.IsLocal=true;Z=ab else return false,S("local var or function def expected")end elseif s:ConsumeSymbol('::',_)then if not s:Is('Ident')then return false,S('Label name expected')end;local aa=s:Get(_).Data;if not s:ConsumeSymbol('::',_)then return false,S("`::` expected")end;local aA={}aA.AstType='LabelStatement'aA.Label=aa;aA.Tokens=_;Z=aA elseif s:ConsumeKeyword('return',_)then local aa={}if not s:IsKeyword('end')then local R,ab=U(r)if R then aa[1]=ab;while s:ConsumeSymbol(',',_)do local R,aB=U(r)if not R then return false,aB end;aa[#aa+1]=aB end end end;local aA={}aA.AstType='ReturnStatement'aA.Arguments=aa;aA.Tokens=_;Z=aA elseif s:ConsumeKeyword('continue',_)then local aa={}aa.AstType='ContinueStatement'aa.Tokens=_;Z=aa elseif s:ConsumeKeyword('break',_)then local aa={}aa.AstType='BreakStatement'aa.Tokens=_;Z=aa elseif s:ConsumeKeyword('goto',_)then if not s:Is('Ident')then return false,S("Label expected")end;local aa=s:Get(_).Data;local aA={}aA.AstType='GotoStatement'aA.Label=aa;aA.Tokens=_;Z=aA else local R,aa=x(r)if not R then return false,aa end;local aA=s:Peek()if Y[aA.Data]then local ab=s:Get(_).Data;if(aa.ParenCount or 0)>0 then return false,S("Cannot assign to a parenthesized expression.")end;local aB,ac=U(r)if not aB then return false,ac end;local aC={}aC.AstType='SpecialAssignmentStatement'aC.Lhs=aa;aC.Operator=ab;aC.Rhs=ac;aC.Tokens=_;Z=aC elseif s:IsSymbol(',')or s:IsSymbol('=')then if(aa.ParenCount or 0)>0 then return false,S("Can not assign to parenthesized expression, is not an lvalue")end;local ab={aa}while s:ConsumeSymbol(',',_)do local R,ad=x(r)if not R then return false,ad end;ab[#ab+1]=ad end;if not s:ConsumeSymbol('=',_)then return false,S("`=` Expected.")end;local aB={}local R,ac=U(r)if not R then return false,ac end;aB[1]=ac;while s:ConsumeSymbol(',',_)do local R,ad=U(r)if not R then return false,ad end;aB[#aB+1]=ad end;local aC={}aC.AstType='AssignmentStatement'aC.Lhs=ab;aC.Rhs=aB;aC.Tokens=_;Z=aC elseif aa.AstType=='CallExpr'or aa.AstType=='TableCallExpr'or aa.AstType=='StringCallExpr'then local ab={}ab.AstType='CallStatement'ab.Expression=aa;ab.Tokens=_;Z=ab else return false,S("Assignment Statement Expected")end end;if s:IsSymbol(';')then Z.Semicolon=s:Get(Z.Tokens)end;return true,Z end;local P=i{'end','else','elseif','until'}v=function(r)local Z={}Z.Scope=u(r)Z.AstType='Statlist'Z.Body={}Z.Tokens={}while not P[s:Peek().Data]and not s:IsEof()do local R,_=p(Z.Scope)if not R then return false,_ end;Z.Body[#Z.Body+1]=_ end;if s:IsEof()then local _={}_.AstType='Eof'_.Tokens={s:Get()}Z.Body[#Z.Body+1]=_ end;return true,Z end;local function q()local r=u()return v(r)end;local R,Q=q()return R,Q end;return{LexLua=n,ParseLua=N}end;E[1]=function()local H=e()E[1]=function()return H end;return H end end;do local e=function()local H={new=function(i,I)local j={Parent=I,Locals={},Globals={},oldLocalNamesMap={},oldGlobalNamesMap={},Children={}}if I then table.insert(I.Children,j)end;return setmetatable(j,{__index=i})end,AddLocal=function(i,I)table.insert(i.Locals,I)end,AddGlobal=function(i,I)table.insert(i.Globals,I)end,CreateLocal=function(i,I)local j;j=i:GetLocal(I)if j then return j end;j={}j.Scope=i;j.Name=I;j.IsGlobal=false;j.CanRename=true;j.References=1;i:AddLocal(j)return j end,GetLocal=function(i,I)for j,J in pairs(i.Locals)do if J.Name==I then return J end end;if i.Parent then return i.Parent:GetLocal(I)end end,GetOldLocal=function(i,I)if i.oldLocalNamesMap[I]then return i.oldLocalNamesMap[I]end;return i:GetLocal(I)end,mapLocal=function(i,I,j)i.oldLocalNamesMap[I]=j end,GetOldGlobal=function(i,I)if i.oldGlobalNamesMap[I]then return i.oldGlobalNamesMap[I]end;return i:GetGlobal(I)end,mapGlobal=function(i,I,j)i.oldGlobalNamesMap[I]=j end,GetOldVariable=function(i,I)return i:GetOldLocal(I)or i:GetOldGlobal(I)end,RenameLocal=function(i,I,j)I=type(I)=='string'and I or I.Name;local J=false;local k=i:GetLocal(I)if k then k.Name=j;i:mapLocal(I,k)J=true end;if not J and i.Parent then i.Parent:RenameLocal(I,j)end end,RenameGlobal=function(i,I,j)I=type(I)=='string'and I or I.Name;local J=false;local k=i:GetGlobal(I)if k then k.Name=j;i:mapGlobal(I,k)J=true end;if not J and i.Parent then i.Parent:RenameGlobal(I,j)end end,RenameVariable=function(i,I,j)I=type(I)=='string'and I or I.Name;if i:GetLocal(I)then i:RenameLocal(I,j)else i:RenameGlobal(I,j)end end,GetAllVariables=function(i)local I=i:getVars(true)for j,J in pairs(i:getVars(false))do table.insert(I,J)end;return I end,getVars=function(i,I)local j={}if I then for J,k in pairs(i.Children)do for K,l in pairs(k:getVars(true))do table.insert(j,l)end end else for J,k in pairs(i.Locals)do table.insert(j,k)end;for J,k in pairs(i.Globals)do table.insert(j,k)end;if i.Parent then for J,k in pairs(i.Parent:getVars(false))do table.insert(j,k)end end end;return j end,CreateGlobal=function(i,I)local j;j=i:GetGlobal(I)if j then return j end;j={}j.Scope=i;j.Name=I;j.IsGlobal=true;j.CanRename=true;j.References=1;i:AddGlobal(j)return j end,GetGlobal=function(i,I)for j,J in pairs(i.Globals)do if J.Name==I then return J end end;if i.Parent then return i.Parent:GetGlobal(I)end end,GetVariable=function(i,I)return i:GetLocal(I)or i:GetGlobal(I)end,ObfuscateLocals=function(i,I,j)I=I or 7;local J="aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ_"local k="0123456789"local K=J..k;for l,L in pairs(i.Locals)do local m="a"local M={1}local n=0;while i:GetVariable(m)do local N=#M>1 and#K or#J;M[#M]=M[#M]+1;for o=1,#M-1 do if M[o+1]>N then M[o]=M[o]+1;M[o+1]=1 end end;if M[1]>N then M[1]=1;table.insert(M,1)end;m=""for o=1,#M do m=m..K:sub(M[o],M[o])end end;i:RenameLocal(L.Name,m)end end}return H end;E[5]=function()local H=e()E[5]=function()return H end;return H end end;do local e=function()local H=E[1]()local i=H.ParseLua;local I=E[4]()local j=I.lookupify;local J=j{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local k=j{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local K=j{'0','1','2','3','4','5','6','7','8','9'}local l=j{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local function L(m)local M,n;local N=0;local function o(p,P,q)q=q or' 'local Q,r=p:sub(-1,-1),P:sub(1,1)if k[Q]or J[Q]or Q=='_'then if not(k[r]or J[r]or r=='_'or K[r])then return p..P elseif r=='('then return p..q..P else return p..q..P end elseif K[Q]then if r=='('then return p..P elseif l[r]then return p..P else return p..q..P end elseif Q==''then return p..P else if r=='('then return p..q..P else return p..P end end end;n=function(p,P)local P=P or 0;local q=0;local Q=false;local r=""if p.AstType=='VarExpr'then if p.Variable then r=r..p.Variable.Name else r=r..p.Name end elseif p.AstType=='NumberExpr'then r=r..p.Value.Data elseif p.AstType=='StringExpr'then r=r..p.Value.Data elseif p.AstType=='BooleanExpr'then r=r..tostring(p.Value)elseif p.AstType=='NilExpr'then r=o(r,"nil")elseif p.AstType=='BinopExpr'then q=p.OperatorPrecedence;r=o(r,n(p.Lhs,q))r=o(r,p.Op)r=o(r,n(p.Rhs))if p.Op=='^'or p.Op=='..'then q=q-1 end;if q<P then Q=false else Q=true end elseif p.AstType=='UnopExpr'then r=o(r,p.Op)r=o(r,n(p.Rhs))elseif p.AstType=='DotsExpr'then r=r.."..."elseif p.AstType=='CallExpr'then r=r..n(p.Base)r=r.."("for R=1,#p.Arguments do r=r..n(p.Arguments[R])if R~=#p.Arguments then r=r..","end end;r=r..")"elseif p.AstType=='TableCallExpr'then r=r..n(p.Base)r=r..n(p.Arguments[1])elseif p.AstType=='StringCallExpr'then r=r..n(p.Base)r=r..p.Arguments[1].Data elseif p.AstType=='IndexExpr'then r=r..n(p.Base).."["..n(p.Index).."]"elseif p.AstType=='MemberExpr'then r=r..n(p.Base)..p.Indexer..p.Ident.Data elseif p.AstType=='Function'then p.Scope:ObfuscateVariables()r=r.."function("if#p.Arguments>0 then for R=1,#p.Arguments do r=r..p.Arguments[R].Name;if R~=#p.Arguments then r=r..","elseif p.VarArg then r=r..",..."end end elseif p.VarArg then r=r.."..."end;r=r..")"r=o(r,M(p.Body))r=o(r,"end")elseif p.AstType=='ConstructorExpr'then r=r.."{"for R=1,#p.EntryList do local s=p.EntryList[R]if s.Type=='Key'then r=r.."["..n(s.Key).."]="..n(s.Value)elseif s.Type=='Value'then r=r..n(s.Value)elseif s.Type=='KeyString'then r=r..s.Key.."="..n(s.Value)end;if R~=#p.EntryList then r=r..","end end;r=r.."}"elseif p.AstType=='IfExpression'then local R=n(p.Condition)local s=n(p.TrueExpression)local S=n(p.FalseExpression)r="(if "..R.." then "..s.." else "..S..")"elseif p.AstType=='Parentheses'then r=r.."("..n(p.Inner)..")"end;if not Q then r=string.rep('(',p.ParenCount or 0)..r;r=r..string.rep(')',p.ParenCount or 0)end;N=N+#r;return r end;local O=function(p)local P=''if p.AstType=='AssignmentStatement'then for q=1,#p.Lhs do P=P..n(p.Lhs[q])if q~=#p.Lhs then P=P..","end end;if#p.Rhs>0 then P=P.."="for q=1,#p.Rhs do P=P..n(p.Rhs[q])if q~=#p.Rhs then P=P..","end end end elseif p.AstType=='SpecialAssignmentStatement'then P=P..n(p.Lhs)P=P..p.Operator;P=P..n(p.Rhs)elseif p.AstType=='CallStatement'then P=n(p.Expression)elseif p.AstType=='LocalStatement'then P=P.."local "for q=1,#p.LocalList do P=P..p.LocalList[q].Name;if q~=#p.LocalList then P=P..","end end;if#p.InitList>0 then P=P.."="for q=1,#p.InitList do P=P..n(p.InitList[q])if q~=#p.InitList then P=P..","end end end elseif p.AstType=='IfStatement'then P=o("if",n(p.Clauses[1].Condition))P=o(P,"then")P=o(P,M(p.Clauses[1].Body))for q=2,#p.Clauses do local Q=p.Clauses[q]if Q.Condition then P=o(P,"elseif")P=o(P,n(Q.Condition))P=o(P,"then")else P=o(P,"else")end;P=o(P,M(Q.Body))end;P=o(P,"end")elseif p.AstType=='WhileStatement'then P=o("while",n(p.Condition))P=o(P,"do")P=o(P,M(p.Body))P=o(P,"end")elseif p.AstType=='DoStatement'then P=o(P,"do")P=o(P,M(p.Body))P=o(P,"end")elseif p.AstType=='ReturnStatement'then P="return"for q=1,#p.Arguments do P=o(P,n(p.Arguments[q]))if q~=#p.Arguments then P=P..","end end elseif p.AstType=='ContinueStatement'then P="continue"elseif p.AstType=='BreakStatement'then P="break"elseif p.AstType=='RepeatStatement'then P="repeat"P=o(P,M(p.Body))P=o(P,"until")P=o(P,n(p.Condition))elseif p.AstType=='Function'then p.Scope:ObfuscateVariables()if p.IsLocal then P="local"end;P=o(P,"function ")if p.IsLocal then P=P..p.Name.Name else P=P..n(p.Name)end;P=P.."("if#p.Arguments>0 then for q=1,#p.Arguments do P=P..p.Arguments[q].Name;if q~=#p.Arguments then P=P..","elseif p.VarArg then P=P..",..."end end elseif p.VarArg then P=P.."..."end;P=P..")"P=o(P,M(p.Body))P=o(P,"end")elseif p.AstType=='GenericForStatement'then p.Scope:ObfuscateVariables()P="for "for q=1,#p.VariableList do P=P..p.VariableList[q].Name;if q~=#p.VariableList then P=P..","end end;P=P.." in"for q=1,#p.Generators do P=o(P,n(p.Generators[q]))if q~=#p.Generators then P=o(P,',')end end;P=o(P,"do")P=o(P,M(p.Body))P=o(P,"end")elseif p.AstType=='NumericForStatement'then p.Scope:ObfuscateVariables()P="for "P=P..p.Variable.Name.."="P=P..n(p.Start)..","..n(p.End)if p.Step then P=P..","..n(p.Step)end;P=o(P,"do")P=o(P,M(p.Body))P=o(P,"end")elseif p.AstType=='LabelStatement'then P=getIndentation().."::"..p.Label.."::"elseif p.AstType=='GotoStatement'then P=getIndentation().."goto "..p.Label elseif p.AstType=='Comment'then elseif p.AstType=='Eof'then else print("Unknown AST Type: "..p.AstType)end;N=N+#P;return P end;M=function(p)local P=''p.Scope:ObfuscateVariables()for q,Q in pairs(p.Body)do P=o(P,O(Q),';')end;return P end;m.Scope:ObfuscateVariables()return M(m)end;return L end;E[2]=function()local H=e()E[2]=function()return H end;return H end end;local f=E[1]()local h=E[2]()local F=f.ParseLua;local g={}local function G(e)return e:match("(.*/)")or"./"end;local function a(e)e=e:gsub("\\","/")e=e:gsub("//","/")local i={}for H in e:gmatch("[^/]+")do if H==".."then table.remove(i)elseif H~="."then table.insert(i,H)end end;return table.concat(i,"/")end;local function A(e,i)i=i and(i:match("/$")and i or i.."/")or""local H={e,i..e,i..e..".lua",i..e..".luau",i..e:gsub("%.","/"),i..e:gsub("%.","/")..".lua",i..e:gsub("%.","/")..".luau",i..e:sub(1,1)..e:sub(2):gsub("%.","/"),i..e:sub(1,1)..e:sub(2):gsub("%.","/")..".lua",i..e:sub(1,1)..e:sub(2):gsub("%.","/")..".luau"}for I,j in ipairs(H)do local J=io.open(j,"r")if J then local K=J:read("*all")J:close()return K,j end end;return nil end;local function b(e)local i={e..".lua",e..".luau",e:gsub("%.","/"),e:gsub("%.","/")..".lua",e:gsub("%.","/")..".luau",e:sub(1,1)..e:sub(2):gsub("%.","/"),e:sub(1,1)..e:sub(2):gsub("%.","/")..".lua",e:sub(1,1)..e:sub(2):gsub("%.","/")..".luau"}for H=1,#i do local I=i[H]local j=io.open(I,"r")if j~=nil then j:close()return I end end end;function g.bundle(e,K,l,L,H,i,I,j,J)for n,o in next,J do e=e:gsub(n,function()return o end)end;e=g.minifyLua(e)K=K or K==nil;l=l or nil;H=H or{}i=i or{}local k={}j=j or 1;I=I==nil and"__MODULES_"..g.makeid(25)or I;local function m(n)local function o(N)local P;local q,Q=pcall(function()P=b(L..N)end)if not q or not P then return("require\"%s\""):format(N)end;local O=H[P]or j;if not H[P]then H[P]=j;j=j+1 end;if l then k[l]=k[l]or{}table.insert(k[l],N)end;return I.."["..O.."]()"end;n=n:gsub('require%s*[%(%s]*([%\'"%[])(.-)%1[%)%s]*',function(N,p)return o(p)end)return n end;local M=m(e)for n,o in pairs(H)do if not i[n]then local N=A(n,L)if N then i[n]=N;local p=g.bundle(N,false,n,L,H,i,I,j,J)i[n]=p else print("WARNING: Failed to read module "..n)end end end;if K then local n=string.format([[
local %s = {}
]],I)for N,o in pairs(H)do n=n..string.format([[
do
    local module = function()
        %s
    end
    %s[%d] = function()
        local ret = module()
        %s[%d] = function() return ret end
        return ret
    end
end
]],i[N],I,o,I,o)end;M=n..M end;return M end;function g.makeid(e)local I="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"local j="0123456789"local J=""local H=true;for i=1,e do local k=H and I or(I..j)local K=math.random(#k)J=J..k:sub(K,K)H=false end;return J end;function g.removeComments(e)e=e:gsub("%-%-.-\n","\n")e=e:gsub("%-%-%[%[.-%]%]","")return e end;function g.minifyLua(e)local H,i=F(e)if not H then error(i)return end;return h(i)end;function g.writeFile(e,i)local H=io.open(e,"w")if not H then return false end;H:write(i)H:close()return true end;function g.main(e,H,i)e=e or"main.lua"H=H or"bundled.min.lua"local J,K=A(e)if not J then print("ERROR: Cannot read "..e)return false end;J=g.minifyLua(J)local k=g.bundle(J,true,nil,G(K),nil,nil,nil,nil,i)local I=g.minifyLua(k)if g.writeFile(H,I)then print("Bundling and minification completed successfully.")return true else print("Failed to write "..H)return false end end;math.randomseed(os.time())local B={...}if#B<1 then error("Usage: bundle.lua [entrypoint] [?-o output]")end;local c=B[1]local C=""do local e={}for i in c:gmatch("([^.]+)")do table.insert(e,i)end;if#e>1 and e[#e]=="lua"then table.remove(e,#e)end;C=table.concat(e,".")end;local d=C..".min.lua"local D={}for e=2,#B-1 do if B[e]:lower()=="-o"then d=B[e+1]e=e+1 elseif B[e]:lower()=="-d"then local H,i=B[e+1]:match("(%w+)%s*=%s*(.-)%s*$")if type(H)=="string"and type(i)=="string"then D[H]=i end end end;g.main(c,d,D)