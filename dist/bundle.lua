local g={}do local F=function()local G={new=function(h,H)local i={Parent=H,Locals={},Globals={},oldLocalNamesMap={},oldGlobalNamesMap={},Children={}}if H then table.insert(H.Children,i)end;return setmetatable(i,{__index=h})end,AddLocal=function(h,H)table.insert(h.Locals,H)end,AddGlobal=function(h,H)table.insert(h.Globals,H)end,CreateLocal=function(h,H)local i;i=h:GetLocal(H)if i then return i end;i={}i.Scope=h;i.Name=H;i.IsGlobal=false;i.CanRename=true;i.References=1;h:AddLocal(i)return i end,GetLocal=function(h,H)for i,I in pairs(h.Locals)do if I.Name==H then return I end end;if h.Parent then return h.Parent:GetLocal(H)end end,GetOldLocal=function(h,H)if h.oldLocalNamesMap[H]then return h.oldLocalNamesMap[H]end;return h:GetLocal(H)end,mapLocal=function(h,H,i)h.oldLocalNamesMap[H]=i end,GetOldGlobal=function(h,H)if h.oldGlobalNamesMap[H]then return h.oldGlobalNamesMap[H]end;return h:GetGlobal(H)end,mapGlobal=function(h,H,i)h.oldGlobalNamesMap[H]=i end,GetOldVariable=function(h,H)return h:GetOldLocal(H)or h:GetOldGlobal(H)end,RenameLocal=function(h,H,i)H=type(H)=='string'and H or H.Name;local I=false;local j=h:GetLocal(H)if j then j.Name=i;h:mapLocal(H,j)I=true end;if not I and h.Parent then h.Parent:RenameLocal(H,i)end end,RenameGlobal=function(h,H,i)H=type(H)=='string'and H or H.Name;local I=false;local j=h:GetGlobal(H)if j then j.Name=i;h:mapGlobal(H,j)I=true end;if not I and h.Parent then h.Parent:RenameGlobal(H,i)end end,RenameVariable=function(h,H,i)H=type(H)=='string'and H or H.Name;if h:GetLocal(H)then h:RenameLocal(H,i)else h:RenameGlobal(H,i)end end,GetAllVariables=function(h)local H=h:getVars(true)for i,I in pairs(h:getVars(false))do table.insert(H,I)end;return H end,getVars=function(h,H)local i={}if H then for I,j in pairs(h.Children)do for J,k in pairs(j:getVars(true))do table.insert(i,k)end end else for I,j in pairs(h.Locals)do table.insert(i,j)end;for I,j in pairs(h.Globals)do table.insert(i,j)end;if h.Parent then for I,j in pairs(h.Parent:getVars(false))do table.insert(i,j)end end end;return i end,CreateGlobal=function(h,H)local i;i=h:GetGlobal(H)if i then return i end;i={}i.Scope=h;i.Name=H;i.IsGlobal=true;i.CanRename=true;i.References=1;h:AddGlobal(i)return i end,GetGlobal=function(h,H)for i,I in pairs(h.Globals)do if I.Name==H then return I end end;if h.Parent then return h.Parent:GetGlobal(H)end end,GetVariable=function(h,H)return h:GetLocal(H)or h:GetGlobal(H)end,ObfuscateLocals=function(h,H,i)H=H or 7;local I="aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ_"local j="0123456789"local J=I..j;for k,K in pairs(h.Locals)do local l="a"local L={1}local m=0;while h:GetVariable(l)do local M=#L>1 and#J or#I;L[#L]=L[#L]+1;for n=1,#L-1 do if L[n+1]>M then L[n]=L[n]+1;L[n+1]=1 end end;if L[1]>M then L[1]=1;table.insert(L,1)end;l=""for n=1,#L do l=l..J:sub(L[n],L[n])end end;h:RenameLocal(K.Name,l)end end}return G end;g[5]=function()local G=F()g[5]=function()return G end;return G end end;do local F=function()local G=g[1]()local h=G.ParseLua;local H=g[3]()local i=H.lookupify;local I=i{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local j=i{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local J=i{'0','1','2','3','4','5','6','7','8','9'}local k=i{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local function K(l)local L,m;local M=0;local function n(o,O,p)p=p or' 'local P,q=o:sub(-1,-1),O:sub(1,1)if j[P]or I[P]or P=='_'then if not(j[q]or I[q]or q=='_'or J[q])then return o..O elseif q=='('then print("==============>>>",P,q)return o..p..O else return o..p..O end elseif J[P]then if q=='('then return o..O elseif k[q]then return o..O else return o..p..O end elseif P==''then return o..O else if q=='('then return o..p..O else return o..O end end end;m=function(o,O)local O=O or 0;local p=0;local P=false;local q=""if o.AstType=='VarExpr'then if o.Variable then q=q..o.Variable.Name else q=q..o.Name end elseif o.AstType=='NumberExpr'then q=q..o.Value.Data elseif o.AstType=='StringExpr'then q=q..o.Value.Data elseif o.AstType=='BooleanExpr'then q=q..tostring(o.Value)elseif o.AstType=='NilExpr'then q=n(q,"nil")elseif o.AstType=='BinopExpr'then p=o.OperatorPrecedence;q=n(q,m(o.Lhs,p))q=n(q,o.Op)q=n(q,m(o.Rhs))if o.Op=='^'or o.Op=='..'then p=p-1 end;if p<O then P=false else P=true end elseif o.AstType=='UnopExpr'then q=n(q,o.Op)q=n(q,m(o.Rhs))elseif o.AstType=='DotsExpr'then q=q.."..."elseif o.AstType=='CallExpr'then q=q..m(o.Base)q=q.."("for Q=1,#o.Arguments do q=q..m(o.Arguments[Q])if Q~=#o.Arguments then q=q..","end end;q=q..")"elseif o.AstType=='TableCallExpr'then q=q..m(o.Base)q=q..m(o.Arguments[1])elseif o.AstType=='StringCallExpr'then q=q..m(o.Base)q=q..o.Arguments[1].Data elseif o.AstType=='IndexExpr'then q=q..m(o.Base).."["..m(o.Index).."]"elseif o.AstType=='MemberExpr'then q=q..m(o.Base)..o.Indexer..o.Ident.Data elseif o.AstType=='Function'then o.Scope:ObfuscateVariables()q=q.."function("if#o.Arguments>0 then for Q=1,#o.Arguments do q=q..o.Arguments[Q].Name;if Q~=#o.Arguments then q=q..","elseif o.VarArg then q=q..",..."end end elseif o.VarArg then q=q.."..."end;q=q..")"q=n(q,L(o.Body))q=n(q,"end")elseif o.AstType=='ConstructorExpr'then q=q.."{"for Q=1,#o.EntryList do local r=o.EntryList[Q]if r.Type=='Key'then q=q.."["..m(r.Key).."]="..m(r.Value)elseif r.Type=='Value'then q=q..m(r.Value)elseif r.Type=='KeyString'then q=q..r.Key.."="..m(r.Value)end;if Q~=#o.EntryList then q=q..","end end;q=q.."}"elseif o.AstType=='Parentheses'then q=q.."("..m(o.Inner)..")"end;if not P then q=string.rep('(',o.ParenCount or 0)..q;q=q..string.rep(')',o.ParenCount or 0)end;M=M+#q;return q end;local N=function(o)local O=''if o.AstType=='AssignmentStatement'then for p=1,#o.Lhs do O=O..m(o.Lhs[p])if p~=#o.Lhs then O=O..","end end;if#o.Rhs>0 then O=O.."="for p=1,#o.Rhs do O=O..m(o.Rhs[p])if p~=#o.Rhs then O=O..","end end end elseif o.AstType=='CallStatement'then O=m(o.Expression)elseif o.AstType=='LocalStatement'then O=O.."local "for p=1,#o.LocalList do O=O..o.LocalList[p].Name;if p~=#o.LocalList then O=O..","end end;if#o.InitList>0 then O=O.."="for p=1,#o.InitList do O=O..m(o.InitList[p])if p~=#o.InitList then O=O..","end end end elseif o.AstType=='IfStatement'then O=n("if",m(o.Clauses[1].Condition))O=n(O,"then")O=n(O,L(o.Clauses[1].Body))for p=2,#o.Clauses do local P=o.Clauses[p]if P.Condition then O=n(O,"elseif")O=n(O,m(P.Condition))O=n(O,"then")else O=n(O,"else")end;O=n(O,L(P.Body))end;O=n(O,"end")elseif o.AstType=='WhileStatement'then O=n("while",m(o.Condition))O=n(O,"do")O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='DoStatement'then O=n(O,"do")O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='ReturnStatement'then O="return"for p=1,#o.Arguments do O=n(O,m(o.Arguments[p]))if p~=#o.Arguments then O=O..","end end elseif o.AstType=='BreakStatement'then O="break"elseif o.AstType=='RepeatStatement'then O="repeat"O=n(O,L(o.Body))O=n(O,"until")O=n(O,m(o.Condition))elseif o.AstType=='Function'then o.Scope:ObfuscateVariables()if o.IsLocal then O="local"end;O=n(O,"function ")if o.IsLocal then O=O..o.Name.Name else O=O..m(o.Name)end;O=O.."("if#o.Arguments>0 then for p=1,#o.Arguments do O=O..o.Arguments[p].Name;if p~=#o.Arguments then O=O..","elseif o.VarArg then O=O..",..."end end elseif o.VarArg then O=O.."..."end;O=O..")"O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='GenericForStatement'then o.Scope:ObfuscateVariables()O="for "for p=1,#o.VariableList do O=O..o.VariableList[p].Name;if p~=#o.VariableList then O=O..","end end;O=O.." in"for p=1,#o.Generators do O=n(O,m(o.Generators[p]))if p~=#o.Generators then O=n(O,',')end end;O=n(O,"do")O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='NumericForStatement'then o.Scope:ObfuscateVariables()O="for "O=O..o.Variable.Name.."="O=O..m(o.Start)..","..m(o.End)if o.Step then O=O..","..m(o.Step)end;O=n(O,"do")O=n(O,L(o.Body))O=n(O,"end")elseif o.AstType=='LabelStatement'then O=getIndentation().."::"..o.Label.."::"elseif o.AstType=='GotoStatement'then O=getIndentation().."goto "..o.Label elseif o.AstType=='Comment'then elseif o.AstType=='Eof'then else print("Unknown AST Type: "..o.AstType)end;M=M+#O;return O end;L=function(o)local O=''o.Scope:ObfuscateVariables()for p,P in pairs(o.Body)do O=n(O,N(P),';')end;return O end;l.Scope:ObfuscateVariables()return L(l)end;return K end;g[2]=function()local G=F()g[2]=function()return G end;return G end end;do local F=function()if"true"=="true"then __STRICT=true;function global()end;return end;local G=getmetatable(_G)if G==nil then G={}setmetatable(_G,G)end;__STRICT=true;G.__declared={}G.__newindex=function(h,H,i)if __STRICT and not G.__declared[H]then local I=debug.getinfo(2,"S").what;if I~="main"and I~="C"then error("assign to undeclared variable '"..H.."'",2)end;G.__declared[H]=true end;rawset(h,H,i)end;G.__index=function(h,H)if not G.__declared[H]and debug.getinfo(2,"S").what~="C"then error("variable '"..H.."' is not declared",2)end;return rawget(h,H)end;function global(...)for h,H in ipairs{...}do G.__declared[H]=true end end end;g[4]=function()local G=F()g[4]=function()return G end;return G end end;do local F=function()local function G(j)for J,k in pairs(j)do j[k]=true end;return j end;local function h(j)local J=0;for k in pairs(j)do J=J+1 end;return J end;local function H(j,J)if j.Print then return j.Print()end;J=J or 0;local k=(h(j)>1)local K=string.rep('    ',J+1)local l="{".. (k and'\n'or'')for L,m in pairs(j)do if type(m)~='function'then l=l.. (k and K or'')if type(L)=='number'then elseif type(L)=='string'and L:match("^[A-Za-z_][A-Za-z0-9_]*$")then l=l..L.." = "elseif type(L)=='string'then l=l.."[\""..L.."\"] = "else l=l.."["..tostring(L).."] = "end;if type(m)=='string'then l=l.."\""..m.."\""elseif type(m)=='number'then l=l..m elseif type(m)=='table'then l=l..H(m,J+ (k and 1 or 0))else l=l..tostring(m)end;if next(j,L)then l=l..","end;if k then l=l..'\n'end end end;l=l.. (k and string.rep('    ',J)or'').."}"return l end;local function i(j)if j:match("\n")then local J={}for k in j:gmatch("[^\n]*")do table.insert(J,k)end;assert(#J>0)return J else return{j}end end;local function I(j,...)return print(string.format(j,...))end;return{PrintTable=H,CountTable=h,lookupify=G,splitLines=i,printf=I}end;g[3]=function()local G=F()g[3]=function()return G end;return G end end;do local F=function()g[4]()local G=g[3]()local h=G.lookupify;local H=h{' ','\n','\t','\r'}local i={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'"}local I=h{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local j=h{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local J=h{'0','1','2','3','4','5','6','7','8','9'}local k=h{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}local K=h{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local l=g[5]()local L=h{'and','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'}local function m(n)local N={}local o,O=pcall(function()local r=1;local p=1;local R=1;local function s()local U=n:sub(r,r)if U=='\n'then R=1;p=p+1 else R=R+1 end;r=r+1;return U end;local function S(U)U=U or 0;return n:sub(r+U,r+U)end;local function t(U)local v=S()for V=1,#U do if v==U:sub(V,V)then return s()end end end;local function T(U)return error(">> :"..p..":"..R..": "..U,0)end;local function u()local U=r;if S()=='['then local v=0;local V=1;while S(v+1)=='='do v=v+1 end;if S(v+1)=='['then for X=0,v+1 do s()end;local w=r;while true do if S()==''then T("Expected `]"..string.rep('=',v).."]` near <eof>.",3)end;local X=true;if S()==']'then for y=1,v do if S(y)~='='then X=false end end;if S(v+1)~=']'then X=false end else if S()=='['then local y=true;for Y=1,v do if S(Y)~='='then y=false;break end end;if S(v+1)=='['and y then V=V+1;for Y=1,(v+2)do s()end end end;X=false end;if X then V=V-1;if V==0 then break else for y=1,v+2 do s()end end else s()end end;local W=n:sub(w,r-1)for X=0,v+1 do s()end;local x=n:sub(U,r-1)return W,x else return nil end else return nil end end;while true do local U={}local v=''local V=false;while true do local Y=S()if Y=='#'and S(1)=='!'and p==1 then s()s()v="#!"while S()~='\n'and S()~=''do v=v..s()end;local z={Type='Comment',CommentType='Shebang',Data=v,Line=p,Char=R}z.Print=function()return"<".. (z.Type..string.rep(' ',7-#z.Type)).."  ".. (z.Data or'').." >"end;v=""table.insert(U,z)end;if Y==' 'or Y=='\t'then local z=s()table.insert(U,{Type='Whitespace',Line=p,Char=R,Data=z})elseif Y=='\n'or Y=='\r'then local z=s()if v~=""then local Z={Type='Comment',CommentType=V and'LongComment'or'Comment',Data=v,Line=p,Char=R}Z.Print=function()return"<".. (Z.Type..string.rep(' ',7-#Z.Type)).."  ".. (Z.Data or'').." >"end;table.insert(U,Z)v=""end;table.insert(U,{Type='Whitespace',Line=p,Char=R,Data=z})elseif Y=='-'and S(1)=='-'then s()s()v=v..'--'local z,Z=u()if Z then v=v..Z;V=true else while S()~='\n'and S()~=''do v=v..s()end end else break end end;if v~=""then local Y={Type='Comment',CommentType=V and'LongComment'or'Comment',Data=v,Line=p,Char=R}Y.Print=function()return"<".. (Y.Type..string.rep(' ',7-#Y.Type)).."  ".. (Y.Data or'').." >"end;table.insert(U,Y)end;local w=p;local W=R;local x=":"..p..":"..R..":> "local X=S()local y=nil;if X==''then y={Type='Eof'}elseif j[X]or I[X]or X=='_'then local Y=r;repeat s()X=S()until not(j[X]or I[X]or J[X]or X=='_')local z=n:sub(Y,r-1)if L[z]then y={Type='Keyword',Data=z}else y={Type='Ident',Data=z}end elseif J[X]or(S()=='.'and J[S(1)])then local Y=r;if X=='0'and S(1)=='x'then s()s()while k[S()]do s()end;if t('Pp')then t('+-')while J[S()]do s()end end else while J[S()]do s()end;if t('.')then while J[S()]do s()end end;if t('Ee')then t('+-')while J[S()]do s()end end end;y={Type='Number',Data=n:sub(Y,r-1)}elseif X=='\''or X=='\"'then local Y=r;local z=s()local Z=r;while true do local X=s()if X=='\\'then s()elseif X==z then break elseif X==''then T("Unfinished string near <eof>")end end;local _=n:sub(Z,r-2)local aa=n:sub(Y,r-1)y={Type='String',Data=aa,Constant=_}elseif X=='['then local Y,z=u()if z then y={Type='String',Data=z,Constant=Y}else s()y={Type='Symbol',Data='['}end elseif t('>=<')then if t('=')then y={Type='Symbol',Data=X..'='}else y={Type='Symbol',Data=X}end elseif t('~')then if t('=')then y={Type='Symbol',Data='~='}else T("Unexpected symbol `~` in source.",2)end elseif t('.')then if t('.')then if t('.')then y={Type='Symbol',Data='...'}else y={Type='Symbol',Data='..'}end else y={Type='Symbol',Data='.'}end elseif t(':')then if t(':')then y={Type='Symbol',Data='::'}else y={Type='Symbol',Data=':'}end elseif K[X]then s()y={Type='Symbol',Data=X}else local Y,z=u()if Y then y={Type='String',Data=z,Constant=Y}else T("Unexpected Symbol `"..X.."` in source.",2)end end;y.LeadingWhite=U;y.Line=w;y.Char=W;y.Print=function()return"<".. (y.Type..string.rep(' ',7-#y.Type)).."  ".. (y.Data or'').." >"end;N[#N+1]=y;if y.Type=='Eof'then break end end end)if not o then return false,O end;local P={}local q={}local Q=1;function P:getp()return Q end;function P:setp(p)Q=p end;function P:getTokenList()return N end;function P:Peek(p)p=p or 0;return N[math.min(#N,Q+p)]end;function P:Get(p)local r=N[Q]Q=math.min(Q+1,#N)if p then table.insert(p,r)end;return r end;function P:Is(p)return P:Peek().Type==p end;function P:Save()q[#q+1]=Q end;function P:Commit()q[#q]=nil end;function P:Restore()Q=q[#q]q[#q]=nil end;function P:ConsumeSymbol(p,r)local R=self:Peek()if R.Type=='Symbol'then if p then if R.Data==p then self:Get(r)return true else return nil end else self:Get(r)return R end else return nil end end;function P:ConsumeKeyword(p,r)local R=self:Peek()if R.Type=='Keyword'and R.Data==p then self:Get(r)return true else return nil end end;function P:IsKeyword(p)local r=P:Peek()return r.Type=='Keyword'and r.Data==p end;function P:IsSymbol(p)local r=P:Peek()return r.Type=='Symbol'and r.Data==p end;function P:IsEof()return P:Peek().Type=='Eof'end;return true,P end;local function M(n)local N,o;if type(n)~='table'then N,o=m(n)else N,o=true,n end;if not N then return false,o end;local function O(X)local y=">> :"..o:Peek().Line..":"..o:Peek().Char..": "..X.."\n"local Y=0;if type(n)=='string'then for z in n:gmatch("[^\n]*\n?")do if z:sub(-1,-1)=='\n'then z=z:sub(1,-2)end;Y=Y+1;if Y==o:Peek().Line then y=y..">> `"..z:gsub('\t','    ').."`\n"for Z=1,o:Peek().Char do local _=z:sub(Z,Z)if _=='\t'then y=y..'    'else y=y..' 'end end;y=y.."   ^^^^"break end end end;return y end;local p=0;local P={'_','a','b','c','d'}local function q(X)local y=l:new(X)y.RenameVars=y.ObfuscateLocals;y.ObfuscateVariables=y.ObfuscateLocals;y.Print=function()return"<Scope>"end;return y end;local Q;local r;local R,s,S,t;local function T(X,y)local Y=q(X)if not o:ConsumeSymbol('(',y)then return false,O("`(` expected.")end;local z={}local Z=false;while not o:ConsumeSymbol(')',y)do if o:Is('Ident')then local aA=Y:CreateLocal(o:Get(y).Data)z[#z+1]=aA;if not o:ConsumeSymbol(',',y)then if o:ConsumeSymbol(')',y)then break else return false,O("`)` expected.")end end elseif o:ConsumeSymbol('...',y)then Z=true;if not o:ConsumeSymbol(')',y)then return false,O("`...` must be the last argument of a function.")end;break else return false,O("Argument name or `...` expected")end end;local N,_=r(Y)if not N then return false,_ end;if not o:ConsumeKeyword('end',y)then return false,O("`end` expected after function body")end;local aa={}aa.AstType='Function'aa.Scope=Y;aa.Arguments=z;aa.Body=_;aa.VarArg=Z;aa.Tokens=y;return true,aa end;function S(X)local y={}if o:ConsumeSymbol('(',y)then local N,Y=Q(X)if not N then return false,Y end;if not o:ConsumeSymbol(')',y)then return false,O("`)` Expected.")end;if false then Y.ParenCount=(Y.ParenCount or 0)+1;return true,Y else local z={}z.AstType='Parentheses'z.Inner=Y;z.Tokens=y;return true,z end elseif o:Is('Ident')then local Y=o:Get(y)local z=X:GetLocal(Y.Data)if not z then z=X:GetGlobal(Y.Data)if not z then z=X:CreateGlobal(Y.Data)else z.References=z.References+1 end else z.References=z.References+1 end;local Z={}Z.AstType='VarExpr'Z.Name=Y.Data;Z.Variable=z;Z.Tokens=y;return true,Z else return false,O("primary expression expected")end end;function t(X,y)local N,Y=S(X)if not N then return false,Y end;while true do local z={}if o:IsSymbol('.')or o:IsSymbol(':')then local Z=o:Get(z).Data;if not o:Is('Ident')then return false,O("<Ident> expected.")end;local _=o:Get(z)local aa={}aa.AstType='MemberExpr'aa.Base=Y;aa.Indexer=Z;aa.Ident=_;aa.Tokens=z;Y=aa elseif not y and o:ConsumeSymbol('[',z)then local N,Z=Q(X)if not N then return false,Z end;if not o:ConsumeSymbol(']',z)then return false,O("`]` expected.")end;local _={}_.AstType='IndexExpr'_.Base=Y;_.Index=Z;_.Tokens=z;Y=_ elseif not y and o:ConsumeSymbol('(',z)then local Z={}while not o:ConsumeSymbol(')',z)do local N,aa=Q(X)if not N then return false,aa end;Z[#Z+1]=aa;if not o:ConsumeSymbol(',',z)then if o:ConsumeSymbol(')',z)then break else return false,O("`)` Expected.")end end end;local _={}_.AstType='CallExpr'_.Base=Y;_.Arguments=Z;_.Tokens=z;Y=_ elseif not y and o:Is('String')then local Z={}Z.AstType='StringCallExpr'Z.Base=Y;Z.Arguments={o:Get(z)}Z.Tokens=z;Y=Z elseif not y and o:IsSymbol('{')then local N,Z=R(X)if not N then return false,Z end;local _={}_.AstType='TableCallExpr'_.Base=Y;_.Arguments={Z}_.Tokens=z;Y=_ else break end end;return true,Y end;function R(X)local y={}if o:Is('Number')then local Y={}Y.AstType='NumberExpr'Y.Value=o:Get(y)Y.Tokens=y;return true,Y elseif o:Is('String')then local Y={}Y.AstType='StringExpr'Y.Value=o:Get(y)Y.Tokens=y;return true,Y elseif o:ConsumeKeyword('nil',y)then local Y={}Y.AstType='NilExpr'Y.Tokens=y;return true,Y elseif o:IsKeyword('false')or o:IsKeyword('true')then local Y={}Y.AstType='BooleanExpr'Y.Value=(o:Get(y).Data=='true')Y.Tokens=y;return true,Y elseif o:ConsumeSymbol('...',y)then local Y={}Y.AstType='DotsExpr'Y.Tokens=y;return true,Y elseif o:ConsumeSymbol('{',y)then local Y={}Y.AstType='ConstructorExpr'Y.EntryList={}while true do if o:IsSymbol('[',y)then o:Get(y)local N,z=Q(X)if not N then return false,O("Key Expression Expected")end;if not o:ConsumeSymbol(']',y)then return false,O("`]` Expected")end;if not o:ConsumeSymbol('=',y)then return false,O("`=` Expected")end;local N,Z=Q(X)if not N then return false,O("Value Expression Expected")end;Y.EntryList[#Y.EntryList+1]={Type='Key',Key=z,Value=Z}elseif o:Is('Ident')then local z=o:Peek(1)if z.Type=='Symbol'and z.Data=='='then local Z=o:Get(y)if not o:ConsumeSymbol('=',y)then return false,O("`=` Expected")end;local N,_=Q(X)if not N then return false,O("Value Expression Expected")end;Y.EntryList[#Y.EntryList+1]={Type='KeyString',Key=Z.Data,Value=_}else local N,Z=Q(X)if not N then return false,O("Value Exected")end;Y.EntryList[#Y.EntryList+1]={Type='Value',Value=Z}end elseif o:ConsumeSymbol('}',y)then break else local N,z=Q(X)Y.EntryList[#Y.EntryList+1]={Type='Value',Value=z}if not N then return false,O("Value Expected")end end;if o:ConsumeSymbol(';',y)or o:ConsumeSymbol(',',y)then elseif o:ConsumeSymbol('}',y)then break else return false,O("`}` or table entry Expected")end end;Y.Tokens=y;return true,Y elseif o:ConsumeKeyword('function',y)then local N,Y=T(X,y)if not N then return false,Y end;Y.IsLocal=true;return true,Y else return t(X)end end;local u=h{'-','not','#'}local U=8;local v={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}function s(X,y)local N,Y;if u[o:Peek().Data]then local z={}local Z=o:Get(z).Data;N,Y=s(X,U)if not N then return false,Y end;local _={}_.AstType='UnopExpr'_.Rhs=Y;_.Op=Z;_.OperatorPrecedence=U;_.Tokens=z;Y=_ else N,Y=R(X)if not N then return false,Y end end;while true do local z=v[o:Peek().Data]if z and z[1]>y then local Z={}local _=o:Get(Z).Data;local N,aa=s(X,z[2])if not N then return false,aa end;local aA={}aA.AstType='BinopExpr'aA.Lhs=Y;aA.Op=_;aA.OperatorPrecedence=z[1]aA.Rhs=aa;aA.Tokens=Z;Y=aA else break end end;return true,Y end;Q=function(X)return s(X,0)end;local function V(X)local y=nil;local Y={}if o:ConsumeKeyword('if',Y)then local z={}z.AstType='IfStatement'z.Clauses={}repeat local N,Z=Q(X)if not N then return false,Z end;if not o:ConsumeKeyword('then',Y)then return false,O("`then` expected.")end;local N,_=r(X)if not N then return false,_ end;z.Clauses[#z.Clauses+1]={Condition=Z,Body=_}until not o:ConsumeKeyword('elseif',Y)if o:ConsumeKeyword('else',Y)then local N,Z=r(X)if not N then return false,Z end;z.Clauses[#z.Clauses+1]={Body=Z}end;if not o:ConsumeKeyword('end',Y)then return false,O("`end` expected.")end;z.Tokens=Y;y=z elseif o:ConsumeKeyword('while',Y)then local z={}z.AstType='WhileStatement'local N,Z=Q(X)if not N then return false,Z end;if not o:ConsumeKeyword('do',Y)then return false,O("`do` expected.")end;local N,_=r(X)if not N then return false,_ end;if not o:ConsumeKeyword('end',Y)then return false,O("`end` expected.")end;z.Condition=Z;z.Body=_;z.Tokens=Y;y=z elseif o:ConsumeKeyword('do',Y)then local N,z=r(X)if not N then return false,z end;if not o:ConsumeKeyword('end',Y)then return false,O("`end` expected.")end;local Z={}Z.AstType='DoStatement'Z.Body=z;Z.Tokens=Y;y=Z elseif o:ConsumeKeyword('for',Y)then if not o:Is('Ident')then return false,O("<ident> expected.")end;local z=o:Get(Y)if o:ConsumeSymbol('=',Y)then local Z=q(X)local _=Z:CreateLocal(z.Data)local N,aa=Q(X)if not N then return false,aa end;if not o:ConsumeSymbol(',',Y)then return false,O("`,` Expected")end;local N,aA=Q(X)if not N then return false,aA end;local N,ab;if o:ConsumeSymbol(',',Y)then N,ab=Q(X)if not N then return false,ab end end;if not o:ConsumeKeyword('do',Y)then return false,O("`do` expected")end;local N,aB=r(Z)if not N then return false,aB end;if not o:ConsumeKeyword('end',Y)then return false,O("`end` expected")end;local ac={}ac.AstType='NumericForStatement'ac.Scope=Z;ac.Variable=_;ac.Start=aa;ac.End=aA;ac.Step=ab;ac.Body=aB;ac.Tokens=Y;y=ac else local Z=q(X)local _={Z:CreateLocal(z.Data)}while o:ConsumeSymbol(',',Y)do if not o:Is('Ident')then return false,O("for variable expected.")end;_[#_+1]=Z:CreateLocal(o:Get(Y).Data)end;if not o:ConsumeKeyword('in',Y)then return false,O("`in` expected.")end;local aa={}local N,aA=Q(X)if not N then return false,aA end;aa[#aa+1]=aA;while o:ConsumeSymbol(',',Y)do local N,ac=Q(X)if not N then return false,ac end;aa[#aa+1]=ac end;if not o:ConsumeKeyword('do',Y)then return false,O("`do` expected.")end;local N,ab=r(Z)if not N then return false,ab end;if not o:ConsumeKeyword('end',Y)then return false,O("`end` expected.")end;local aB={}aB.AstType='GenericForStatement'aB.Scope=Z;aB.VariableList=_;aB.Generators=aa;aB.Body=ab;aB.Tokens=Y;y=aB end elseif o:ConsumeKeyword('repeat',Y)then local N,z=r(X)if not N then return false,z end;if not o:ConsumeKeyword('until',Y)then return false,O("`until` expected.")end;local N,Z=Q(z.Scope)if not N then return false,Z end;local _={}_.AstType='RepeatStatement'_.Condition=Z;_.Body=z;_.Tokens=Y;y=_ elseif o:ConsumeKeyword('function',Y)then if not o:Is('Ident')then return false,O("Function name expected")end;local N,z=t(X,true)if not N then return false,z end;local N,Z=T(X,Y)if not N then return false,Z end;Z.IsLocal=false;Z.Name=z;y=Z elseif o:ConsumeKeyword('local',Y)then if o:Is('Ident')then local z={o:Get(Y).Data}while o:ConsumeSymbol(',',Y)do if not o:Is('Ident')then return false,O("local var name expected")end;z[#z+1]=o:Get(Y).Data end;local Z={}if o:ConsumeSymbol('=',Y)then repeat local N,aa=Q(X)if not N then return false,aa end;Z[#Z+1]=aa until not o:ConsumeSymbol(',',Y)end;for aa,aA in pairs(z)do z[aa]=X:CreateLocal(aA)end;local _={}_.AstType='LocalStatement'_.LocalList=z;_.InitList=Z;_.Tokens=Y;y=_ elseif o:ConsumeKeyword('function',Y)then if not o:Is('Ident')then return false,O("Function name expected")end;local z=o:Get(Y).Data;local Z=X:CreateLocal(z)local N,_=T(X,Y)if not N then return false,_ end;_.Name=Z;_.IsLocal=true;y=_ else return false,O("local var or function def expected")end elseif o:ConsumeSymbol('::',Y)then if not o:Is('Ident')then return false,O('Label name expected')end;local z=o:Get(Y).Data;if not o:ConsumeSymbol('::',Y)then return false,O("`::` expected")end;local Z={}Z.AstType='LabelStatement'Z.Label=z;Z.Tokens=Y;y=Z elseif o:ConsumeKeyword('return',Y)then local z={}if not o:IsKeyword('end')then local N,_=Q(X)if N then z[1]=_;while o:ConsumeSymbol(',',Y)do local N,aa=Q(X)if not N then return false,aa end;z[#z+1]=aa end end end;local Z={}Z.AstType='ReturnStatement'Z.Arguments=z;Z.Tokens=Y;y=Z elseif o:ConsumeKeyword('break',Y)then local z={}z.AstType='BreakStatement'z.Tokens=Y;y=z elseif o:ConsumeKeyword('goto',Y)then if not o:Is('Ident')then return false,O("Label expected")end;local z=o:Get(Y).Data;local Z={}Z.AstType='GotoStatement'Z.Label=z;Z.Tokens=Y;y=Z else local N,z=t(X)if not N then return false,z end;if o:IsSymbol(',')or o:IsSymbol('=')then if(z.ParenCount or 0)>0 then return false,O("Can not assign to parenthesized expression, is not an lvalue")end;local Z={z}while o:ConsumeSymbol(',',Y)do local N,ab=t(X)if not N then return false,ab end;Z[#Z+1]=ab end;if not o:ConsumeSymbol('=',Y)then return false,O("`=` Expected.")end;local _={}local N,aa=Q(X)if not N then return false,aa end;_[1]=aa;while o:ConsumeSymbol(',',Y)do local N,ab=Q(X)if not N then return false,ab end;_[#_+1]=ab end;local aA={}aA.AstType='AssignmentStatement'aA.Lhs=Z;aA.Rhs=_;aA.Tokens=Y;y=aA elseif z.AstType=='CallExpr'or z.AstType=='TableCallExpr'or z.AstType=='StringCallExpr'then local Z={}Z.AstType='CallStatement'Z.Expression=z;Z.Tokens=Y;y=Z else return false,O("Assignment Statement Expected")end end;if o:IsSymbol(';')then y.Semicolon=o:Get(y.Tokens)end;return true,y end;local w=h{'end','else','elseif','until'}r=function(X)local y={}y.Scope=q(X)y.AstType='Statlist'y.Body={}y.Tokens={}while not w[o:Peek().Data]and not o:IsEof()do local N,Y=V(y.Scope)if not N then return false,Y end;y.Body[#y.Body+1]=Y end;if o:IsEof()then local Y={}Y.AstType='Eof'Y.Tokens={o:Get()}y.Body[#y.Body+1]=Y end;return true,y end;local function W()local X=q()return r(X)end;local N,x=W()return N,x end;return{LexLua=m,ParseLua=M}end;g[1]=function()local G=F()g[1]=function()return G end;return G end end;local a=g[1]()local A=g[2]()local b=a.ParseLua;local B={}local function c(F)return F:match("(.*/)")or"./"end;local function C(F)F=F:gsub("\\","/")F=F:gsub("//","/")local G={}for h in F:gmatch("[^/]+")do if h==".."then table.remove(G)elseif h~="."then table.insert(G,h)end end;return table.concat(G,"/")end;local function d(F,G)G=G and(G:match("/$")and G or G.."/")or""local h={F,G..F,G..F..".lua"}for H,i in ipairs(h)do local I=io.open(i,"r")if I then local j=I:read("*all")I:close()return j,i end end;return nil end;function B.bundle(F,G,h,H,i,I,j,J)G=G or G==nil;h=h or nil;i=i or{}I=I or{}local k={}J=J or 1;j=j==nil and"__MODULES_"..B.makeid(25)or j;local function K(L)local function m(M)local n=io.open(H..M,"r")or io.open(H..M..".lua","r")if not n then return("require\"%s\""):format(M)end;n:close()local N=i[M]or J;if not i[M]then i[M]=J;J=J+1 end;if h then k[h]=k[h]or{}table.insert(k[h],M)end;return j.."["..N.."]()"end;L=L:gsub('require%s*[%(%s]*([%\'"%[])(.-)%1[%)%s]*',function(M,n)return m(n)end)L=L:gsub('%true%',function()return"true"end)return L end;local l=K(F)for L,m in pairs(i)do if not I[L]then local M=d(L,H)if M then I[L]=M;local n=B.bundle(M,false,L,H,i,I,j,J)I[L]=n else print("WARNING: Failed to read module "..L)end end end;if G then local L=string.format([[
local %s = {}
]],j)for m,M in pairs(i)do L=L..string.format([[
do
    local module = function()
        %s
    end
    %s[%d] = function()
        local ret = module()
        %s[%d] = function() return ret end
        return ret
    end
end
]],I[m],j,M,j,M)end;l=L..l end;return l end;function B.makeid(F)local G="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"local h="0123456789"local H=""local i=true;for I=1,F do local j=i and G or(G..h)local J=math.random(#j)H=H..j:sub(J,J)i=false end;return H end;function B.removeComments(F)F=F:gsub("%-%-.-\n","\n")F=F:gsub("%-%-%[%[.-%]%]","")return F end;function B.minifyLua(F)local G,h=b(F)if not G then error(h)return end;return A(h)end;function B.writeFile(F,G)local h=io.open(F,"w")if not h then return false end;h:write(G)h:close()return true end;function B.main(F,G)F=F or"main.lua"G=G or"bundled.min.lua"local h,H=d(F)if not h then print("ERROR: Cannot read "..F)return false end;local i=B.bundle(h,true,nil,c(H))local I=B.minifyLua(i)if B.writeFile(G,I)then print("Bundling and minification completed successfully.")return true else print("Failed to write "..G)return false end end;math.randomseed(os.time())local D={...}if#D<1 then error("Usage: bundle.lua [entrypoint] [?-o output]")end;local e=D[1]local E=""do local F={}for G in e:gmatch("([^.]+)")do table.insert(F,G)end;if#F>1 and F[#F]=="lua"then table.remove(F,#F)end;E=table.concat(F,".")end;local f=E..".min.lua"for F=2,#D-1 do if D[F]:lower()=="-o"then f=D[F+1]end end;B.main(e,f)